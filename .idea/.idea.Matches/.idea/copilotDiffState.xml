<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/CollectibleTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/CollectibleTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct CollectibleTriggeredEvent&#10;    {&#10;        public InteractableObjectController CollectibleObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/FinishLineTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/FinishLineTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct FinishLineTriggeredEvent&#10;    {&#10;        public InteractableObjectController FinishLineObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/ObstacleTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/ObstacleTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct ObstacleTriggeredEvent&#10;    {&#10;        public InteractableObjectController ObstacleObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs" />
              <option name="updatedContent" value="namespace Core&#10;{&#10;    public interface ILevel&#10;    {&#10;        void Load();&#10;        void Unload();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core&#10;{&#10;    public class Level : MonoBehaviour, ILevel&#10;    {&#10;        [SerializeField] private string levelName;&#10;        [SerializeField] private bool isLoaded;&#10;        &#10;        public string LevelName =&gt; levelName;&#10;        public bool IsLoaded =&gt; isLoaded;&#10;        &#10;        public virtual void Load()&#10;        {&#10;            if (!isLoaded)&#10;            {&#10;                OnLevelLoad();&#10;                isLoaded = true;&#10;                Debug.Log($&quot;Level {levelName} loaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        public virtual void Unload()&#10;        {&#10;            if (isLoaded)&#10;            {&#10;                OnLevelUnload();&#10;                isLoaded = false;&#10;                Debug.Log($&quot;Level {levelName} unloaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        // Override edilebilir metodlar&#10;        protected virtual void OnLevelLoad()&#10;        {&#10;            // Level yüklenirken yapılacak işlemler&#10;        }&#10;        &#10;        protected virtual void OnLevelUnload()&#10;        {&#10;            // Level boşaltılırken yapılacak işlemler&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            if (string.IsNullOrEmpty(levelName))&#10;            {&#10;                levelName = gameObject.name;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System;&#10;using MiniGameFramework.Core;&#10;using MiniGameFramework.Events;&#10;&#10;namespace MiniGameFramework.Match3&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#10;    /// Extends MiniGameBase for framework integration&#10;    /// &lt;/summary&gt;&#10;    public class Match3Game : MiniGameBase&#10;    {&#10;        [Header(&quot;Game Configuration&quot;)]&#10;        [SerializeField] private int targetScore = 1000;&#10;        [SerializeField] private int movesLimit = 30;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#10;        &#10;        [Header(&quot;System References&quot;)]&#10;        [SerializeField] private GridManager gridManager;&#10;        [SerializeField] private InputHandler inputHandler;&#10;        [SerializeField] private SwapHandler swapHandler;&#10;        [SerializeField] private MatchFinder matchFinder;&#10;        [SerializeField] private RefillSystem refillSystem;&#10;        &#10;        // Game state&#10;        private int movesRemaining;&#10;        private int cascadeLevel;&#10;        private bool isProcessingMatches;&#10;        private GameState gameState;&#10;        &#10;        // Additional events specific to Match-3&#10;        public event Action&lt;int&gt; OnMovesChanged;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#10;        public event Action OnCascadeStarted;&#10;        public event Action OnCascadeEnded;&#10;        &#10;        // IMiniGame Implementation&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#10;        public bool IsInitialized { get; private set; }&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#10;&#10;        // Events&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#10;&#10;        // Properties&#10;        public int CurrentScore =&gt; currentScore;&#10;        public int MovesRemaining =&gt; movesRemaining;&#10;        public int TargetScore =&gt; targetScore;&#10;        public GameState State =&gt; gameState;&#10;        &#10;        private void Awake()&#10;        {&#10;            ValidateComponents();&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        private void ValidateComponents()&#10;        {&#10;            if (gridManager == null) gridManager = GetComponent&lt;GridManager&gt;();&#10;            if (inputHandler == null) inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            if (swapHandler == null) swapHandler = GetComponent&lt;SwapHandler&gt;();&#10;            if (matchFinder == null) matchFinder = GetComponent&lt;MatchFinder&gt;();&#10;            if (refillSystem == null) refillSystem = GetComponent&lt;RefillSystem&gt;();&#10;        }&#10;        &#10;        #region MiniGameBase Overrides&#10;        &#10;        protected override void OnInitialize()&#10;        {&#10;            // Initialize all systems&#10;            matchFinder.Initialize(gridManager);&#10;            swapHandler.Initialize(gridManager, matchFinder);&#10;            inputHandler.Initialize(gridManager, swapHandler);&#10;            refillSystem.Initialize(gridManager);&#10;            &#10;            // Subscribe to events&#10;            SubscribeToEvents();&#10;            &#10;            // Setup initial grid&#10;            refillSystem.InitialFillGrid();&#10;            &#10;            // Ensure no initial matches&#10;            StartCoroutine(ClearInitialMatches());&#10;        }&#10;        &#10;        protected override void OnGameStart()&#10;        {&#10;            // Reset game state&#10;            movesRemaining = movesLimit;&#10;            cascadeLevel = 0;&#10;            isProcessingMatches = false;&#10;            &#10;            // Enable input&#10;            inputHandler.SetInputEnabled(true);&#10;            &#10;            gameState = GameState.Playing;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            &#10;            // Publish game started event&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Ready, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGamePause()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Paused;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Paused));&#10;        }&#10;        &#10;        protected override void OnGameResume()&#10;        {&#10;            inputHandler.SetInputEnabled(true);&#10;            gameState = GameState.Playing;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Paused, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGameEnd()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Ended;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Ended));&#10;        }&#10;        &#10;        protected override void OnCleanup()&#10;        {&#10;            UnsubscribeFromEvents();&#10;            &#10;            if (gridManager != null)&#10;                gridManager.ClearGrid();&#10;&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Event Handling&#10;        &#10;        private void SubscribeToEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted += OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted += OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted -= OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted -= OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void OnSwapCompleted(Vector2Int pos1, Vector2Int pos2, bool wasSuccessful)&#10;        {&#10;            if (!IsGameActive()) return;&#10;            &#10;            // Publish swap event&#10;            Events.Events.Publish(new PieceSwappedEvent(pos1, pos2, wasSuccessful));&#10;            &#10;            if (wasSuccessful)&#10;            {&#10;                // Consume a move&#10;                movesRemaining--;&#10;                OnMovesChanged?.Invoke(movesRemaining);&#10;                Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;                &#10;                // Start cascade processing&#10;                StartCoroutine(ProcessMatches());&#10;                &#10;                // Check for game over conditions&#10;                if (movesRemaining &lt;= 0)&#10;                {&#10;                    StartCoroutine(CheckGameOverAfterCascade());&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void OnRefillCompleted()&#10;        {&#10;            if (!IsPlaying) return;&#10;            &#10;            // Check for new matches after refill&#10;            StartCoroutine(ProcessMatches());&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Match Processing and Cascades&#10;        &#10;        private IEnumerator ProcessMatches()&#10;        {&#10;            if (isProcessingMatches) yield break;&#10;            &#10;            isProcessingMatches = true;&#10;            cascadeLevel = 0;&#10;            int totalCascadeScore = 0;&#10;            &#10;            OnCascadeStarted?.Invoke();&#10;            Events.Events.Publish(new CascadeStartedEvent(cascadeLevel));&#10;            &#10;            bool foundMatches;&#10;            do&#10;            {&#10;                cascadeLevel++;&#10;                &#10;                // Find all matches&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                foundMatches = matches.Count &gt; 0;&#10;                &#10;                if (foundMatches)&#10;                {&#10;                    // Process matches and get the score for this cascade&#10;                    int cascadeScore = ProcessMatchedPieces(matches);&#10;                    totalCascadeScore += cascadeScore;&#10;&#10;                    // Wait for destruction animations to complete&#10;                    yield return new WaitForSeconds(0.5f);&#10;                    &#10;                    // Apply gravity and refill&#10;                    yield return StartCoroutine(refillSystem.RefillGrid());&#10;                    &#10;                    // Wait before checking for new matches&#10;                    yield return new WaitForSeconds(cascadeDelay);&#10;                }&#10;                &#10;            } while (foundMatches);&#10;            &#10;            isProcessingMatches = false;&#10;            OnCascadeEnded?.Invoke();&#10;            Events.Events.Publish(new CascadeEndedEvent(cascadeLevel - 1, totalCascadeScore));&#10;        }&#10;        &#10;        private int ProcessMatchedPieces(List&lt;List&lt;Vector2Int&gt;&gt; matches)&#10;        {&#10;            List&lt;Piece&gt; matchedPieces = new List&lt;Piece&gt;();&#10;            int matchScore = 0;&#10;            &#10;            foreach (var match in matches)&#10;            {&#10;                int matchValue = 0;&#10;                List&lt;Vector2Int&gt; matchPositions = new List&lt;Vector2Int&gt;();&#10;                &#10;                foreach (var position in match)&#10;                {&#10;                    Piece piece = gridManager.GetPiece(position);&#10;                    if (piece != null &amp;&amp; !matchedPieces.Contains(piece))&#10;                    {&#10;                        matchedPieces.Add(piece);&#10;                        matchPositions.Add(position);&#10;                        &#10;                        int pieceScore = piece.GetScore();&#10;                        // Apply cascade multiplier&#10;                        pieceScore *= cascadeLevel;&#10;                        matchValue += pieceScore;&#10;                        &#10;                        // Handle special pieces&#10;                        if (piece.IsSpecial)&#10;                        {&#10;                            piece.ActivateSpecialEffect(position);&#10;                            int specialScore = piece.GetScore(true) * cascadeLevel;&#10;                            matchValue += specialScore;&#10;                            &#10;                            // Publish special piece event&#10;                            Events.Events.Publish(new SpecialPieceActivatedEvent(position, piece.SpecialType, new List&lt;Vector2Int&gt; { position }));&#10;                        }&#10;                        &#10;                        // Trigger match notification&#10;                        piece.OnMatched();&#10;                        &#10;                        // Remove from grid&#10;                        gridManager.RemovePiece(position);&#10;                        &#10;                        // Destroy piece&#10;                        piece.Destroy();&#10;                    }&#10;                }&#10;                &#10;                // Publish match found event&#10;                if (matchPositions.Count &gt; 0)&#10;                {&#10;                    Events.Events.Publish(new MatchFoundEvent(matchPositions, matchValue));&#10;                }&#10;                &#10;                matchScore += matchValue;&#10;            }&#10;            &#10;            // Add score using base class method&#10;            AddScore(matchScore);&#10;            &#10;            OnPiecesMatched?.Invoke(matchedPieces);&#10;            &#10;            return matchScore;&#10;        }&#10;        &#10;        private IEnumerator ClearInitialMatches()&#10;        {&#10;            // Keep clearing matches until no more exist&#10;            while (true)&#10;            {&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                if (matches.Count == 0) break;&#10;                &#10;                // Destroy matched pieces without scoring&#10;                foreach (var match in matches)&#10;                {&#10;                    foreach (var position in match)&#10;                    {&#10;                        Piece piece = gridManager.GetPiece(position);&#10;                        if (piece != null)&#10;                        {&#10;                            gridManager.RemovePiece(position);&#10;                            Destroy(piece.gameObject);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Refill and check again&#10;                yield return StartCoroutine(refillSystem.RefillGrid());&#10;                yield return new WaitForSeconds(0.1f);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Game Over Logic&#10;        &#10;        private IEnumerator CheckGameOverAfterCascade()&#10;        {&#10;            // Wait for current cascade to finish&#10;            while (isProcessingMatches || refillSystem.IsRefilling)&#10;            {&#10;                yield return null;&#10;            }&#10;            &#10;            CheckGameOverConditions();&#10;        }&#10;        &#10;        private void CheckGameOverConditions()&#10;        {&#10;            // Check win condition&#10;            if (currentScore &gt;= targetScore)&#10;            {&#10;                EndGame();&#10;                return;&#10;            }&#10;            &#10;            // Check loss conditions&#10;            if (movesRemaining &lt;= 0)&#10;            {&#10;                // Check if there are still possible moves&#10;                if (!matchFinder.HasPossibleMoves())&#10;                {&#10;                    EndGame();&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Public Interface&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus moves (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public void AddMoves(int moves)&#10;        {&#10;            movesRemaining += moves;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus score (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public new void AddScore(int score)&#10;        {&#10;            base.AddScore(score);&#10;            Events.Events.Publish(new ScoreUpdatedEvent(currentScore, score));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if the game can continue&#10;        /// &lt;/summary&gt;&#10;        public bool CanContinue()&#10;        {&#10;            return movesRemaining &gt; 0 &amp;&amp; matchFinder.HasPossibleMoves();&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Represents the current state of the Match-3 game&#10;    /// &lt;/summary&gt;&#10;    public enum GameState&#10;    {&#10;        NotInitialized,&#10;        Ready,&#10;        Playing,&#10;        Paused,&#10;        Ended&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using System.Collections;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System;&#13;&#10;using MiniGameFramework.Core;&#13;&#10;using MiniGameFramework.Events;&#13;&#10;&#13;&#10;namespace MiniGameFramework.Match3&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#13;&#10;    /// Extends MiniGameBase for framework integration&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public class Match3Game : MiniGameBase&#13;&#10;    {&#13;&#10;        [Header(&quot;Game Configuration&quot;)]&#13;&#10;        [SerializeField] private int targetScore = 1000;&#13;&#10;        [SerializeField] private int movesLimit = 30;&#13;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;System References&quot;)]&#13;&#10;        [SerializeField] private GridManager gridManager;&#13;&#10;        [SerializeField] private InputHandler inputHandler;&#13;&#10;        [SerializeField] private SwapHandler swapHandler;&#13;&#10;        [SerializeField] private MatchFinder matchFinder;&#13;&#10;        [SerializeField] private RefillSystem refillSystem;&#13;&#10;        &#13;&#10;        // Game state&#13;&#10;        private int _currentScore;&#13;&#10;        private int movesRemaining;&#13;&#10;        private int cascadeLevel;&#13;&#10;        private bool isProcessingMatches;&#13;&#10;        private GameState gameState;&#13;&#10;        &#13;&#10;        // Additional events specific to Match-3&#13;&#10;        public event Action&lt;int&gt; OnMovesChanged;&#13;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#13;&#10;        public event Action OnCascadeStarted;&#13;&#10;        public event Action OnCascadeEnded;&#13;&#10;        &#13;&#10;        // IMiniGame Implementation&#13;&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#13;&#10;        public bool IsInitialized { get; private set; }&#13;&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#13;&#10;&#13;&#10;        // Events&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#13;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#13;&#10;&#13;&#10;        // Properties&#13;&#10;        public int CurrentScore =&gt; _currentScore;&#13;&#10;        public int MovesRemaining =&gt; movesRemaining;&#13;&#10;        public int TargetScore =&gt; targetScore;&#13;&#10;        public GameState State =&gt; gameState;&#13;&#10;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public enum GameState&#13;&#10;    {&#13;&#10;        Initializing,&#13;&#10;        Ready,&#13;&#10;        Playing,&#13;&#10;        Paused,&#13;&#10;        GameOver&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EditorTests.asmdef">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EditorTests.asmdef" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EventManagerTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EventManagerTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelManagerTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelManagerTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/MathUtilityTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/MathUtilityTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/UIManagerTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/UIManagerTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Project Matches&#10;&#10;Welcome to the official repository for Project Matches! This document provides a comprehensive guide to the project's architecture, development workflows, and core mechanics.&#10;&#10;## Table of Contents&#10;- [Project Overview](#project-overview)&#10;- [Core Architecture](#core-architecture)&#10;  - [Manager System](#manager-system)&#10;  - [Event System](#event-system)&#10;- [Level Creation Workflow](#level-creation-workflow)&#10;- [Mini-Game Mechanics](#mini-game-mechanics)&#10;  - [Match-3](#match-3)&#10;  - [Runner](#runner)&#10;- [Getting Started](#getting-started)&#10;&#10;## Project Overview&#10;&#10;Project Matches is a versatile Unity-based game framework designed to support various mini-games, starting with a Match-3 and a Runner game. The architecture is highly modular, making it easy to extend and add new features or game modes.&#10;&#10;## Core Architecture&#10;&#10;The project is built upon a robust and modular architecture to ensure scalability and maintainability.&#10;&#10;### Manager System&#10;&#10;The core of the framework is the **Manager System**. A central `ManagerContainer` is responsible for initializing and providing access to all other managers. This ensures a clean separation of concerns and a single point of access for core functionalities.&#10;&#10;The main managers are:&#10;- **`EventManager`**: Handles the communication between different parts of the game using a publish-subscribe pattern.&#10;- **`LevelManager`**: Manages the lifecycle of levels, including loading, starting, and finishing them.&#10;- **`UIManager`**: Controls the user interface, including screens, pop-ups, and HUD elements.&#10;- **`SaveLoadManager`**: Manages game data persistence, saving and loading player progress.&#10;&#10;### Level System&#10;&#10;The `LevelManager` orchestrates the entire level flow, from loading data to managing player progression.&#10;&#10;-   **Level Container**: It loads all level data from a `LevelsContainerSO` asset found in the `Resources` folder. This asset acts as a central repository for all levels in the game.&#10;-   **Lifecycle Management**: It handles the complete lifecycle of a level. It interacts with the `SaveLoadManager` to get the `currentLevelIndex` and load the appropriate level. It provides methods like `StartLevel`, `EndLevel`, and `LoadNextLevel` to control the game flow.&#10;-   **Event Publishing**: It is a key event publisher that informs other systems about the level's state:&#10;    -   `LevelLoadedEvent`: Published after a level's data is loaded. The `UIManager` listens to this to show the start panel.&#10;    -   `LevelStartedEvent`: Published when the gameplay for the current level officially begins.&#10;    -   `LevelEndedEvent`: Published when the level is successfully completed.&#10;    -   `LevelFailedEvent`: Published when the player fails the level.&#10;    -   `LevelUnloadedEvent`: Published when a level's resources are unloaded before loading the next one.&#10;&#10;### UI System&#10;&#10;The `UIManager` controls the entire UI flow of the game. It operates as a state machine, managing different UI panels based on the current game state.&#10;&#10;-   **Panel Controllers:** The manager holds references to various panel controllers, such as `StartPanelController`, `EndPanelController`, and game-specific panels (e.g., `Match3InGamePanelController`).&#10;-   **State-Driven:** It uses a `UIState` enum (e.g., `StartPanel`, `EndPanel`, `InGame`) to determine which panel should be active.&#10;-   **Event-Driven:** The `UIManager` subscribes to core game events from the `EventManager` (`LevelLoadedEvent`, `LevelEndedEvent`, `LevelFailedEvent`). When an event is published, the `UIManager` automatically transitions to the appropriate UI state, showing and hiding panels as needed. For example, when a `LevelLoadedEvent` is received, it shows the start panel. When a `LevelEndedEvent` is received, it displays the end-game panel.&#10;&#10;### Save/Load System&#10;&#10;The `SaveLoadManager` is responsible for all data persistence in the game. It automatically loads user data when the game starts and provides methods to save it.&#10;&#10;-   **Data Model:** Player progress is stored in the `UserSaveData` class.&#10;-   **Storage:** The data is serialized into a JSON file and stored in the device's persistent data path (`Application.persistentDataPath`). This ensures that player data is not lost between sessions.&#10;&#10;### Event System&#10;&#10;The `EventManager` allows for decoupled communication between different systems.&#10;&#10;**Subscribing to an Event:**&#10;&#10;To listen for an event, you need to subscribe to it using its type. The `EventManager` will call your provided method whenever the event is published.&#10;&#10;```csharp&#10;// Example of subscribing to a 'GameStartEvent'&#10;private void OnEnable()&#10;{&#10;    ManagerContainer.Instance.GetManager&lt;EventManager&gt;().Subscribe&lt;GameStartEvent&gt;(OnGameStarted);&#10;}&#10;&#10;private void OnDisable()&#10;{&#10;    ManagerContainer.Instance.GetManager&lt;EventManager&gt;().Unsubscribe&lt;GameStartEvent&gt;(OnGameStarted);&#10;}&#10;&#10;private void OnGameStarted(GameStartEvent gameEvent)&#10;{&#10;    // Handle the event&#10;    Debug.Log(&quot;Game has started!&quot;);&#10;}&#10;```&#10;&#10;**Publishing an Event:**&#10;&#10;To publish an event, simply create an instance of your event class and pass it to the `Publish` method.&#10;&#10;```csharp&#10;// Example of publishing a 'GameStartEvent'&#10;var gameStartEvent = new GameStartEvent();&#10;ManagerContainer.Instance.GetManager&lt;EventManager&gt;().Publish(gameStartEvent);&#10;```&#10;&#10;## Level Creation Workflow&#10;&#10;Levels are created using custom Editor windows, which streamline the design process.&#10;&#10;1.  **Open the Level Editor:** Navigate to `Matches &gt; Match3 Level Creator` or `Matches &gt; Runner Level Creator` in the Unity menu, depending on the desired game type.&#10;2.  **Design the Level:** Use the editor's interface to define the level's properties, such as the grid layout for a Match-3 game or the track segments for a Runner game.&#10;3.  **Save the Level:** The editor will serialize the level data into a `ScriptableObject` asset.&#10;4.  **Add to Level Container:** To make the level accessible in the game, you must add the newly created level asset to the `LevelContainer` `ScriptableObject`. This container holds a list of all available levels. The `LevelManager` uses this container to load levels by their index.&#10;&#10;## Mini-Game Mechanics&#10;&#10;The framework is designed to support different mini-games.&#10;&#10;### Match-3&#10;&#10;-   **Grid System:** The Match-3 game uses a grid system defined in the level data. Each cell in the grid can contain a game piece. The `GridManager` (or a similar class) is responsible for managing the state of the grid.&#10;-   **Input Handling:** Input is typically handled via the `InputManager`, which detects player swipes or clicks on the grid. These inputs are then translated into game actions, like swapping pieces.&#10;&#10;### Runner&#10;&#10;-   **Game Progression:** The Runner game progresses by sequentially spawning track segments. The `LevelManager` loads the level data, which defines the order and type of segments to be used. Player movement and game speed are managed by a dedicated `PlayerController` and `GameManager` for the runner mode.&#10;&#10;## Getting Started&#10;&#10;1.  Clone the repository to your local machine.&#10;2.  Open the project in Unity Hub.&#10;3.  The main scene (e.g., `MainMenu` or `Core`) should be located in the `Assets/Scenes` folder. Open it to get started.&#10;4.  Press Play in the Unity Editor to run the game.&#10;&#10;## Known Issues and Future Improvements&#10;&#10;-   **Empty Level Container:** The system currently does not gracefully handle cases where the `LevelsContainer` is empty. It fails silently without providing a clear error or a fallback mechanism.&#10;-   **Rendering Issues in Runner Game:** The project was initially configured for a 2D rendering pipeline. As a result, the 3D Runner mini-game has some lighting and material rendering artifacts that need to be addressed by adjusting the render pipeline settings.&#10;-   **Lack of Unit Tests:** The project currently lacks unit tests. While the architecture is modular, some components are tightly coupled with Unity's lifecycle, making standard unit testing challenging. Future work could involve refactoring critical parts for better testability.&#10;-   **Animation System:** Animations are primarily handled using Coroutines. Migrating to a dedicated tweening library like **DoTween** could result in cleaner, more performant, and more maintainable animation code.&#10;" />
              <option name="updatedContent" value="# Project Matches&#10;&#10;Welcome to the official repository for Project Matches! This document provides a comprehensive guide to the project's architecture, development workflows, and core mechanics.&#10;&#10;## Table of Contents&#10;- [Project Overview](#project-overview)&#10;- [Core Architecture](#core-architecture)&#10;  - [Manager System](#manager-system)&#10;  - [Event System](#event-system)&#10;- [Level Creation Workflow](#level-creation-workflow)&#10;- [Mini-Game Mechanics](#mini-game-mechanics)&#10;  - [Match-3](#match-3)&#10;  - [Runner](#runner)&#10;- [Getting Started](#getting-started)&#10;&#10;## Project Overview&#10;&#10;Project Matches is a versatile Unity-based game framework designed to support various mini-games, starting with a Match-3 and a Runner game. The architecture is highly modular, making it easy to extend and add new features or game modes.&#10;&#10;## Core Architecture&#10;&#10;The project is built upon a robust and modular architecture to ensure scalability and maintainability.&#10;&#10;### Manager System&#10;&#10;The core of the framework is the **Manager System**. A central `ManagerContainer` is responsible for initializing and providing access to all other managers. This ensures a clean separation of concerns and a single point of access for core functionalities.&#10;&#10;The main managers are:&#10;- **`EventManager`**: Handles the communication between different parts of the game using a publish-subscribe pattern.&#10;- **`LevelManager`**: Manages the lifecycle of levels, including loading, starting, and finishing them.&#10;- **`UIManager`**: Controls the user interface, including screens, pop-ups, and HUD elements.&#10;- **`SaveLoadManager`**: Manages game data persistence, saving and loading player progress.&#10;&#10;### Level System&#10;&#10;The `LevelManager` orchestrates the entire level flow, from loading data to managing player progression.&#10;&#10;-   **Level Container**: It loads all level data from a `LevelsContainerSO` asset found in the `Resources` folder. This asset acts as a central repository for all levels in the game.&#10;-   **Lifecycle Management**: It handles the complete lifecycle of a level. It interacts with the `SaveLoadManager` to get the `currentLevelIndex` and load the appropriate level. It provides methods like `StartLevel`, `EndLevel`, and `LoadNextLevel` to control the game flow.&#10;-   **Event Publishing**: It is a key event publisher that informs other systems about the level's state:&#10;    -   `LevelLoadedEvent`: Published after a level's data is loaded. The `UIManager` listens to this to show the start panel.&#10;    -   `LevelStartedEvent`: Published when the gameplay for the current level officially begins.&#10;    -   `LevelEndedEvent`: Published when the level is successfully completed.&#10;    -   `LevelFailedEvent`: Published when the player fails the level.&#10;    -   `LevelUnloadedEvent`: Published when a level's resources are unloaded before loading the next one.&#10;&#10;### UI System&#10;&#10;The `UIManager` controls the entire UI flow of the game. It operates as a state machine, managing different UI panels based on the current game state.&#10;&#10;-   **Panel Controllers:** The manager holds references to various panel controllers, such as `StartPanelController`, `EndPanelController`, and game-specific panels (e.g., `Match3InGamePanelController`).&#10;-   **State-Driven:** It uses a `UIState` enum (e.g., `StartPanel`, `EndPanel`, `InGame`) to determine which panel should be active.&#10;-   **Event-Driven:** The `UIManager` subscribes to core game events from the `EventManager` (`LevelLoadedEvent`, `LevelEndedEvent`, `LevelFailedEvent`). When an event is published, the `UIManager` automatically transitions to the appropriate UI state, showing and hiding panels as needed. For example, when a `LevelLoadedEvent` is received, it shows the start panel. When a `LevelEndedEvent` is received, it displays the end-game panel.&#10;&#10;### Save/Load System&#10;&#10;The `SaveLoadManager` is responsible for all data persistence in the game. It automatically loads user data when the game starts and provides methods to save it.&#10;&#10;-   **Data Model:** Player progress is stored in the `UserSaveData` class.&#10;-   **Storage:** The data is serialized into a JSON file and stored in the device's persistent data path (`Application.persistentDataPath`). This ensures that player data is not lost between sessions.&#10;&#10;### Event System&#10;&#10;The `EventManager` allows for decoupled communication between different systems.&#10;&#10;**Subscribing to an Event:**&#10;&#10;To listen for an event, you need to subscribe to it using its type. The `EventManager` will call your provided method whenever the event is published.&#10;&#10;```csharp&#10;// Example of subscribing to a 'GameStartEvent'&#10;private void OnEnable()&#10;{&#10;    ManagerContainer.Instance.GetManager&lt;EventManager&gt;().Subscribe&lt;GameStartEvent&gt;(OnGameStarted);&#10;}&#10;&#10;private void OnDisable()&#10;{&#10;    ManagerContainer.Instance.GetManager&lt;EventManager&gt;().Unsubscribe&lt;GameStartEvent&gt;(OnGameStarted);&#10;}&#10;&#10;private void OnGameStarted(GameStartEvent gameEvent)&#10;{&#10;    // Handle the event&#10;    Debug.Log(&quot;Game has started!&quot;);&#10;}&#10;```&#10;&#10;**Publishing an Event:**&#10;&#10;To publish an event, simply create an instance of your event class and pass it to the `Publish` method.&#10;&#10;```csharp&#10;// Example of publishing a 'GameStartEvent'&#10;var gameStartEvent = new GameStartEvent();&#10;ManagerContainer.Instance.GetManager&lt;EventManager&gt;().Publish(gameStartEvent);&#10;```&#10;&#10;## Level Creation Workflow&#10;&#10;Levels are created using custom Editor windows, which streamline the design process.&#10;&#10;1.  **Open the Level Editor:** Navigate to `Matches &gt; Match3 Level Creator` or `Matches &gt; Runner Level Creator` in the Unity menu, depending on the desired game type.&#10;2.  **Design the Level:** Use the editor's interface to define the level's properties, such as the grid layout for a Match-3 game or the track segments for a Runner game.&#10;3.  **Save the Level:** The editor will serialize the level data into a `ScriptableObject` asset.&#10;4.  **Add to Level Container:** To make the level accessible in the game, you must add the newly created level asset to the `LevelContainer` `ScriptableObject`. This container holds a list of all available levels. The `LevelManager` uses this container to load levels by their index.&#10;&#10;## Mini-Game Mechanics&#10;&#10;The framework is designed to support different mini-games.&#10;&#10;### Match-3&#10;&#10;-   **Grid System:** The Match-3 game uses a grid system defined in the level data. Each cell in the grid can contain a game piece. The `GridManager` (or a similar class) is responsible for managing the state of the grid.&#10;-   **Input Handling:** Input is typically handled via the `InputManager`, which detects player swipes or clicks on the grid. These inputs are then translated into game actions, like swapping pieces.&#10;-   **Matching Logic:** After a player's move, the `GridManager` scans the grid for horizontal and vertical matches of three or more identical pieces. When a match is identified, the pieces are removed from the grid. The pieces above then fall down to fill the empty spaces, which can potentially create new matches (cascades). This process repeats until no new matches are formed.&#10;&#10;### Runner&#10;&#10;-   **Game Progression:** The Runner game progresses by sequentially spawning track segments. The `LevelManager` loads the level data, which defines the order and type of segments to be used. Player movement and game speed are managed by a dedicated `PlayerController` and `GameManager` for the runner mode.&#10;&#10;## Third-Party Assets&#10;&#10;- **Free Casual Buttons Pack**: This project includes the [Free Casual Buttons Pack](https://assetstore.unity.com/packages/2d/gui/free-casual-buttons-pack-307406) from the Unity Asset Store to provide placeholder UI elements for visualization purposes.&#10;&#10;## Getting Started&#10;&#10;1.  Clone the repository to your local machine.&#10;2.  Open the project in Unity Hub.&#10;3.  The main scene (e.g., `MainMenu` or `Core`) should be located in the `Assets/Scenes` folder. Open it to get started.&#10;4.  Press Play in the Unity Editor to run the game.&#10;&#10;## Known Issues and Future Improvements&#10;&#10;-   **Empty Level Container:** The system currently does not gracefully handle cases where the `LevelsContainer` is empty. It fails silently without providing a clear error or a fallback mechanism.&#10;-   **Rendering Issues in Runner Game:** The project was initially configured for a 2D rendering pipeline. As a result, the 3D Runner mini-game has some lighting and material rendering artifacts that need to be addressed by adjusting the render pipeline settings.&#10;-   **Lack of Unit Tests:** The project currently lacks unit tests. While the architecture is modular, some components are tightly coupled with Unity's lifecycle, making standard unit testing challenging. Future work could involve refactoring critical parts for better testability.&#10;-   **Animation System:** Animations are primarily handled using Coroutines. Migrating to a dedicated tweening library like **DoTween** could result in cleaner, more performant, and more maintainable animation code." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>