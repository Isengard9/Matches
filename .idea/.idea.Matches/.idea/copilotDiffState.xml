<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs" />
              <option name="updatedContent" value="namespace Core&#10;{&#10;    public interface ILevel&#10;    {&#10;        void Load();&#10;        void Unload();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core&#10;{&#10;    public class Level : MonoBehaviour, ILevel&#10;    {&#10;        [SerializeField] private string levelName;&#10;        [SerializeField] private bool isLoaded;&#10;        &#10;        public string LevelName =&gt; levelName;&#10;        public bool IsLoaded =&gt; isLoaded;&#10;        &#10;        public virtual void Load()&#10;        {&#10;            if (!isLoaded)&#10;            {&#10;                OnLevelLoad();&#10;                isLoaded = true;&#10;                Debug.Log($&quot;Level {levelName} loaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        public virtual void Unload()&#10;        {&#10;            if (isLoaded)&#10;            {&#10;                OnLevelUnload();&#10;                isLoaded = false;&#10;                Debug.Log($&quot;Level {levelName} unloaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        // Override edilebilir metodlar&#10;        protected virtual void OnLevelLoad()&#10;        {&#10;            // Level yüklenirken yapılacak işlemler&#10;        }&#10;        &#10;        protected virtual void OnLevelUnload()&#10;        {&#10;            // Level boşaltılırken yapılacak işlemler&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            if (string.IsNullOrEmpty(levelName))&#10;            {&#10;                levelName = gameObject.name;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/CellController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/CellController.cs" />
              <option name="originalContent" value="using MiniGames.Match3.Data;&#10;using UnityEngine;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class CellController : MonoBehaviour&#10;    {&#10;        public SpriteRenderer SpriteRenderer;&#10;        public Vector2Int GridPosition;&#10;        public CellData CellData;&#10;&#10;        private void Awake()&#10;        {&#10;            // Collider2D yoksa ekle&#10;            if (GetComponent&lt;Collider2D&gt;() == null)&#10;            {&#10;                var collider = gameObject.AddComponent&lt;BoxCollider2D&gt;();&#10;                collider.isTrigger = true;&#10;            }&#10;        }&#10;&#10;        public void SetData(CellData data)&#10;        {&#10;            CellData = data;&#10;            if (data != null &amp;&amp; data.Piece != null)&#10;            {&#10;                SpriteRenderer.sprite = data.Piece.Sprite;&#10;                SpriteRenderer.color = data.Piece.Color;&#10;            }&#10;            else&#10;            {&#10;                SpriteRenderer.sprite = null; // Clear sprite if no piece is assigned&#10;            }&#10;        }&#10;        &#10;        public bool IsWall()&#10;        {&#10;            return CellData?.Piece?.Type == PieceType.Wall;&#10;        }&#10;        &#10;        public bool IsEmpty()&#10;        {&#10;            return CellData == null || CellData.Piece == null;&#10;        }&#10;        &#10;        public bool CanSwap()&#10;        {&#10;            return !IsWall() &amp;&amp; !IsEmpty();&#10;        }&#10;        &#10;        // Animasyon için pozisyon değiştirme metodu&#10;        public void MoveTo(Vector3 targetPosition, float duration = 0.3f)&#10;        {&#10;            StartCoroutine(MoveCoroutine(targetPosition, duration));&#10;        }&#10;        &#10;        private System.Collections.IEnumerator MoveCoroutine(Vector3 targetPosition, float duration)&#10;        {&#10;            Vector3 startPosition = transform.position;&#10;            float elapsedTime = 0;&#10;            &#10;            while (elapsedTime &lt; duration)&#10;            {&#10;                elapsedTime += Time.deltaTime;&#10;                float t = elapsedTime / duration;&#10;                transform.position = Vector3.Lerp(startPosition, targetPosition, t);&#10;                yield return null;&#10;            }&#10;            &#10;            transform.position = targetPosition;&#10;        }&#10;        &#10;        public void MoveLeft()&#10;        {&#10;            &#10;        }&#10;        &#10;        public void MoveRight()&#10;        {&#10;            &#10;        }&#10;        &#10;        public void MoveUp()&#10;        {&#10;            &#10;        }&#10;        &#10;        public void MoveDown()&#10;        {&#10;            &#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using MiniGames.Match3.Data;&#10;using UnityEngine;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class CellController : MonoBehaviour&#10;    {&#10;        public SpriteRenderer SpriteRenderer;&#10;        public Vector2Int GridPosition;&#10;        public CellData CellData;&#10;        &#10;        [SerializeField] private Animator animator;&#10;&#10;        private void Awake()&#10;        {&#10;            // Collider2D yoksa ekle&#10;            if (GetComponent&lt;Collider2D&gt;() == null)&#10;            {&#10;                var collider = gameObject.AddComponent&lt;BoxCollider2D&gt;();&#10;                collider.isTrigger = true;&#10;            }&#10;            &#10;            // Animator referansını al&#10;            if (animator == null)&#10;                animator = GetComponent&lt;Animator&gt;();&#10;        }&#10;&#10;        public void SetData(CellData data)&#10;        {&#10;            CellData = data;&#10;            if (data != null &amp;&amp; data.Piece != null)&#10;            {&#10;                SpriteRenderer.sprite = data.Piece.Sprite;&#10;                SpriteRenderer.color = data.Piece.Color;&#10;            }&#10;            else&#10;            {&#10;                SpriteRenderer.sprite = null; // Clear sprite if no piece is assigned&#10;            }&#10;        }&#10;        &#10;        public bool IsWall()&#10;        {&#10;            return CellData?.Piece?.Type == PieceType.Wall;&#10;        }&#10;        &#10;        public bool IsEmpty()&#10;        {&#10;            return CellData == null || CellData.Piece == null;&#10;        }&#10;        &#10;        public bool CanSwap()&#10;        {&#10;            return !IsWall() &amp;&amp; !IsEmpty();&#10;        }&#10;        &#10;        // Animasyon için pozisyon değiştirme metodu&#10;        public void MoveTo(Vector3 targetPosition, float duration = 0.3f)&#10;        {&#10;            StartCoroutine(MoveCoroutine(targetPosition, duration));&#10;        }&#10;        &#10;        private System.Collections.IEnumerator MoveCoroutine(Vector3 targetPosition, float duration)&#10;        {&#10;            Vector3 startPosition = transform.position;&#10;            float elapsedTime = 0;&#10;            &#10;            while (elapsedTime &lt; duration)&#10;            {&#10;                elapsedTime += Time.deltaTime;&#10;                float t = elapsedTime / duration;&#10;                transform.position = Vector3.Lerp(startPosition, targetPosition, t);&#10;                yield return null;&#10;            }&#10;            &#10;            transform.position = targetPosition;&#10;        }&#10;        &#10;        public void MoveLeft()&#10;        {&#10;            &#10;        }&#10;        &#10;        public void MoveRight()&#10;        {&#10;            &#10;        }&#10;        &#10;        public void MoveUp()&#10;        {&#10;            &#10;        }&#10;        &#10;        public void MoveDown()&#10;        {&#10;            &#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Match animasyonu tetikler&#10;        /// &lt;/summary&gt;&#10;        public void TriggerMatchAnimation()&#10;        {&#10;            if (animator != null)&#10;            {&#10;                animator.SetTrigger(&quot;Match&quot;);&#10;                Debug.Log($&quot;Match animation triggered for cell at {GridPosition}&quot;);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Wrong match animasyonu tetikler&#10;        /// &lt;/summary&gt;&#10;        public void TriggerWrongMatchAnimation()&#10;        {&#10;            if (animator != null)&#10;            {&#10;                animator.SetTrigger(&quot;WrongMatch&quot;);&#10;                Debug.Log($&quot;WrongMatch animation triggered for cell at {GridPosition}&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/GridController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/GridController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using MiniGames.Match3.Data;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    [RequireComponent(typeof(Match3LevelController))]&#10;    public class GridController : MonoBehaviour&#10;    {&#10;        public Match3LevelController levelController;&#10;        public CellController CellPrefab;&#10;&#10;        public CellController[,] Cells;&#10;&#10;        [SerializeField] private float padding = 1.2f;&#10;&#10;        [ContextMenu(&quot;Generate Grid&quot;)]&#10;        public void CreateGrid()&#10;        {&#10;            if (levelController == null || levelController.Match3Data == null ||&#10;                levelController.Match3Data.GridData == null)&#10;            {&#10;                Debug.LogError(&quot;Match3Data or GridData is not set.&quot;);&#10;                return;&#10;            }&#10;&#10;            var gridData = levelController.Match3Data.GridData;&#10;            int gridSize = (int)gridData.GridSize;&#10;&#10;            // Cells array'ini initialize et&#10;            Cells = new CellController[gridSize, gridSize];&#10;&#10;            // Mevcut grid'i temizle (Editor güvenli)&#10;            ClearExistingGrid();&#10;&#10;            // GridData'dan cells'i initialize et&#10;            if (gridData.Cells == null)&#10;            {&#10;                Debug.LogError(&quot;GridData.Cells is not initialized.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Yeni grid oluştur&#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                for (int col = 0; col &lt; gridSize; col++)&#10;                {&#10;                    // World position: col = x, row = y (ama row'u ters çevir çünkü Unity'de Y yukarı doğru pozitif)&#10;                    Vector3 position = new Vector3(col * padding, -row * padding, 0);&#10;                    var cellObj = Instantiate(CellPrefab.gameObject, position, Quaternion.identity, transform);&#10;                    cellObj.name = $&quot;Cell_{row}_{col}&quot;;&#10;&#10;                    CellController cellController = cellObj.GetComponent&lt;CellController&gt;();&#10;                    // Grid position: x = col, y = row (0,0 = sol üst, 4,4 = sağ alt)&#10;                    cellController.GridPosition = new Vector2Int(col, row);&#10;&#10;                    // GridData'dan CellData'yı al ve set et&#10;                    var cellData = gridData.Cells[row, col];&#10;                    cellController.SetData(cellData);&#10;&#10;                    // Cells array'ine kaydet: [row, col] = [y, x]&#10;                    Cells[row, col] = cellController;&#10;                }&#10;            }&#10;        }&#10;&#10;        public void ClearExistingGrid()&#10;        {&#10;            for (int i = transform.childCount - 1; i &gt;= 0; i--)&#10;            {&#10;                Transform child = transform.GetChild(i);&#10;#if UNITY_EDITOR&#10;                if (Application.isPlaying)&#10;                    Destroy(child.gameObject);&#10;                else&#10;                    DestroyImmediate(child.gameObject);&#10;#else&#10;        Destroy(child.gameObject);&#10;#endif&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Swap işlemini dener. Tüm kuralları kontrol eder.&#10;        /// &lt;/summary&gt;&#10;        public bool TrySwap(CellController fromCell, Vector2Int direction)&#10;        {&#10;            if (fromCell == null) return false;&#10;            &#10;            // Hedef pozisyonu hesapla&#10;            Vector2Int fromPos = fromCell.GridPosition;&#10;            Vector2Int toPos = fromPos + direction;&#10;            &#10;            // Grid sınırları içinde mi kontrol et&#10;            if (!IsValidPosition(toPos))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Target position {toPos} is out of bounds&quot;);&#10;                return false;&#10;            }&#10;            &#10;            CellController toCell = Cells[toPos.y, toPos.x];&#10;            &#10;            // Swap kurallarını kontrol et&#10;            if (!CanSwapCells(fromCell, toCell))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Cannot swap {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;            &#10;            // Geçici swap yap ve match kontrol et&#10;            SwapCellData(fromCell, toCell);&#10;            &#10;            bool hasMatches = CheckForMatches(fromPos) || CheckForMatches(toPos);&#10;            &#10;            if (hasMatches)&#10;            {&#10;                Debug.Log($&quot;Swap successful: {fromPos} &lt;-&gt; {toPos}&quot;);&#10;                &#10;                // Animasyonlu swap gerçekleştir&#10;                PerformAnimatedSwap(fromCell, toCell);&#10;                &#10;                // Eşleşen tüm cell'lerde Match animasyonu tetikle&#10;                TriggerMatchAnimationsForAllMatches();&#10;                &#10;                return true;&#10;            }&#10;            else&#10;            {&#10;                // Match bulunamadı, swap'i geri al&#10;                SwapCellData(fromCell, toCell);&#10;                &#10;                // Swap yapılmaya çalışılan cell'lerde WrongMatch animasyonu tetikle&#10;                fromCell.TriggerWrongMatchAnimation();&#10;                toCell.TriggerWrongMatchAnimation();&#10;                &#10;                Debug.Log($&quot;Swap failed: No matches found after swapping {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Grid'deki tüm eşleşmeleri bulur ve Match animasyonu tetikler&#10;        /// &lt;/summary&gt;&#10;        private void TriggerMatchAnimationsForAllMatches()&#10;        {&#10;            List&lt;CellController&gt; matchedCells = new List&lt;CellController&gt;();&#10;            &#10;            if (Cells == null) return;&#10;            &#10;            int gridSize = Cells.GetLength(0);&#10;            &#10;            // Tüm grid'i tara ve eşleşmeleri bul&#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                for (int col = 0; col &lt; gridSize; col++)&#10;                {&#10;                    Vector2Int position = new Vector2Int(col, row);&#10;                    &#10;                    if (CheckForMatches(position))&#10;                    {&#10;                        // Bu pozisyondaki eşleşmeleri bul ve listeye ekle&#10;                        List&lt;CellController&gt; positionMatches = GetMatchedCellsAtPosition(position);&#10;                        &#10;                        foreach (var cell in positionMatches)&#10;                        {&#10;                            if (!matchedCells.Contains(cell))&#10;                            {&#10;                                matchedCells.Add(cell);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Eşleşen tüm cell'lerde Match animasyonu tetikle&#10;            foreach (var cell in matchedCells)&#10;            {&#10;                cell.TriggerMatchAnimation();&#10;            }&#10;            &#10;            Debug.Log($&quot;Match animations triggered for {matchedCells.Count} cells&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda 3'lü match var mı kontrol eder (Sarmal/Dallanma yapısı)&#10;        /// &lt;/summary&gt;&#10;        private bool CheckForMatches(Vector2Int position)&#10;        {&#10;            if (!IsValidPosition(position)) return false;&#10;            &#10;            CellController cell = Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) return false;&#10;            &#10;            Color targetColor = cell.CellData.Piece.Color;&#10;            &#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul (sarmal yapı)&#10;            HashSet&lt;Vector2Int&gt; connectedCells = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedCells);&#10;            &#10;            // 3 veya daha fazla bağlı cell varsa match&#10;            return connectedCells.Count &gt;= 3;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Rekursif olarak bağlı tüm aynı renkli cell'leri bulur (sarmal yapı)&#10;        /// &lt;/summary&gt;&#10;        private void FindConnectedCells(Vector2Int position, Color targetColor, HashSet&lt;Vector2Int&gt; visited)&#10;        {&#10;            // Bu pozisyon zaten ziyaret edildiyse veya geçersizse dur&#10;            if (!IsValidPosition(position) || visited.Contains(position))&#10;                return;&#10;            &#10;            CellController cell = Cells[position.y, position.x];&#10;            &#10;            // Boş, duvar veya farklı renk ise dur&#10;            if (cell.IsEmpty() || cell.IsWall() || !ColorsMatch(cell.CellData.Piece.Color, targetColor))&#10;                return;&#10;            &#10;            // Bu pozisyonu ziyaret edildi olarak işaretle&#10;            visited.Add(position);&#10;            &#10;            // 4 yöne de (sağ, sol, yukarı, aşağı) rekursif olarak devam et&#10;            FindConnectedCells(position + Vector2Int.right, targetColor, visited); // Sağ&#10;            FindConnectedCells(position + Vector2Int.left, targetColor, visited);  // Sol&#10;            FindConnectedCells(position + Vector2Int.up, targetColor, visited);    // Yukarı&#10;            FindConnectedCells(position + Vector2Int.down, targetColor, visited);  // Aşağı&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyondaki tüm bağlı eşleşen cell'leri döndürür (sarmal yapı)&#10;        /// &lt;/summary&gt;&#10;        private List&lt;CellController&gt; GetMatchedCellsAtPosition(Vector2Int position)&#10;        {&#10;            List&lt;CellController&gt; matchedCells = new List&lt;CellController&gt;();&#10;            &#10;            if (!IsValidPosition(position)) return matchedCells;&#10;            &#10;            CellController cell = Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) &#10;                return matchedCells;&#10;            &#10;            Color targetColor = cell.CellData.Piece.Color;&#10;            &#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul&#10;            HashSet&lt;Vector2Int&gt; connectedPositions = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedPositions);&#10;            &#10;            // 3 veya daha fazla bağlı cell varsa listeye ekle&#10;            if (connectedPositions.Count &gt;= 3)&#10;            {&#10;                foreach (var pos in connectedPositions)&#10;                {&#10;                    matchedCells.Add(Cells[pos.y, pos.x]);&#10;                }&#10;            }&#10;            &#10;            return matchedCells;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki cell arasında animasyonlı swap gerçekleştirir&#10;        /// &lt;/summary&gt;&#10;        private void PerformAnimatedSwap(CellController cell1, CellController cell2)&#10;        {&#10;            Vector3 cell1Position = cell1.transform.position;&#10;            Vector3 cell2Position = cell2.transform.position;&#10;            &#10;            // Her iki cell'i de karşı pozisyona animasyonla götür&#10;            cell1.MoveTo(cell2Position);&#10;            cell2.MoveTo(cell1Position);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki cell'in swap edilip edilemeyeceğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool CanSwapCells(CellController fromCell, CellController toCell)&#10;        {&#10;            // Null kontrolleri&#10;            if (fromCell == null || toCell == null) return false;&#10;            &#10;            // Wall kontrolü - Duvar ile hiçbir şey swap edilemez&#10;            if (fromCell.IsWall() || toCell.IsWall())&#10;            {&#10;                return false;&#10;            }&#10;            &#10;            // En az bir cell'de piece olmalı&#10;            if (fromCell.IsEmpty() &amp;&amp; toCell.IsEmpty())&#10;            {&#10;                return false;&#10;            }&#10;            &#10;            return true;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki cell'in data'larını swap eder&#10;        /// &lt;/summary&gt;&#10;        private void SwapCellData(CellController cell1, CellController cell2)&#10;        {&#10;            var cell1Position = cell1.GridPosition;&#10;            var cell2Position = cell2.GridPosition;&#10;           &#10;            // Grid'deki cell'lerin pozisyonlarını güncelle&#10;            Cells[cell1Position.y, cell1Position.x] = cell2;&#10;            Cells[cell2Position.y, cell2Position.x] = cell1;&#10;            // Cell'lerin grid pozisyonlarını güncelle&#10;            cell1.GridPosition = cell2Position;&#10;            cell2.GridPosition = cell1Position;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki rengin eşleşip eşleşmediğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool ColorsMatch(Color color1, Color color2)&#10;        {&#10;            // Renk karşılaştırması için epsilon değeri kullan&#10;            float threshold = 0.1f;&#10;            return Mathf.Abs(color1.r - color2.r) &lt; threshold &amp;&amp;&#10;                   Mathf.Abs(color1.g - color2.g) &lt; threshold &amp;&amp;&#10;                   Mathf.Abs(color1.b - color2.b) &lt; threshold;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Pozisyonun grid sınırları içinde olup olmadığını kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool IsValidPosition(Vector2Int position)&#10;        {&#10;            if (Cells == null) return false;&#10;            &#10;            int gridSize = Cells.GetLength(0);&#10;            return position.x &gt;= 0 &amp;&amp; position.x &lt; gridSize &amp;&amp; &#10;                   position.y &gt;= 0 &amp;&amp; position.y &lt; gridSize;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using MiniGames.Match3.Data;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    [RequireComponent(typeof(Match3LevelController))]&#10;    public class GridController : MonoBehaviour&#10;    {&#10;        public Match3LevelController levelController;&#10;        public CellController CellPrefab;&#10;&#10;        public CellController[,] Cells;&#10;&#10;        [SerializeField] private float padding = 1.2f;&#10;&#10;        [ContextMenu(&quot;Generate Grid&quot;)]&#10;        public void CreateGrid()&#10;        {&#10;            if (levelController == null || levelController.Match3Data == null ||&#10;                levelController.Match3Data.GridData == null)&#10;            {&#10;                Debug.LogError(&quot;Match3Data or GridData is not set.&quot;);&#10;                return;&#10;            }&#10;&#10;            var gridData = levelController.Match3Data.GridData;&#10;            int gridSize = (int)gridData.GridSize;&#10;&#10;            // Cells array'ini initialize et&#10;            Cells = new CellController[gridSize, gridSize];&#10;&#10;            // Mevcut grid'i temizle (Editor güvenli)&#10;            ClearExistingGrid();&#10;&#10;            // GridData'dan cells'i initialize et&#10;            if (gridData.Cells == null)&#10;            {&#10;                Debug.LogError(&quot;GridData.Cells is not initialized.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Yeni grid oluştur&#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                for (int col = 0; col &lt; gridSize; col++)&#10;                {&#10;                    // World position: col = x, row = y (ama row'u ters çevir çünkü Unity'de Y yukarı doğru pozitif)&#10;                    Vector3 position = new Vector3(col * padding, -row * padding, 0);&#10;                    var cellObj = Instantiate(CellPrefab.gameObject, position, Quaternion.identity, transform);&#10;                    cellObj.name = $&quot;Cell_{row}_{col}&quot;;&#10;&#10;                    CellController cellController = cellObj.GetComponent&lt;CellController&gt;();&#10;                    // Grid position: x = col, y = row (0,0 = sol üst, 4,4 = sağ alt)&#10;                    cellController.GridPosition = new Vector2Int(col, row);&#10;&#10;                    // GridData'dan CellData'yı al ve set et&#10;                    var cellData = gridData.Cells[row, col];&#10;                    cellController.SetData(cellData);&#10;&#10;                    // Cells array'ine kaydet: [row, col] = [y, x]&#10;                    Cells[row, col] = cellController;&#10;                }&#10;            }&#10;        }&#10;&#10;        public void ClearExistingGrid()&#10;        {&#10;            for (int i = transform.childCount - 1; i &gt;= 0; i--)&#10;            {&#10;                Transform child = transform.GetChild(i);&#10;#if UNITY_EDITOR&#10;                if (Application.isPlaying)&#10;                    Destroy(child.gameObject);&#10;                else&#10;                    DestroyImmediate(child.gameObject);&#10;#else&#10;        Destroy(child.gameObject);&#10;#endif&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Swap işlemini dener. Tüm kuralları kontrol eder.&#10;        /// &lt;/summary&gt;&#10;        public bool TrySwap(CellController fromCell, Vector2Int direction)&#10;        {&#10;            if (fromCell == null) return false;&#10;            &#10;            // Hedef pozisyonu hesapla&#10;            Vector2Int fromPos = fromCell.GridPosition;&#10;            Vector2Int toPos = fromPos + direction;&#10;            &#10;            // Grid sınırları içinde mi kontrol et&#10;            if (!IsValidPosition(toPos))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Target position {toPos} is out of bounds&quot;);&#10;                return false;&#10;            }&#10;            &#10;            CellController toCell = Cells[toPos.y, toPos.x];&#10;            &#10;            // Swap kurallarını kontrol et&#10;            if (!CanSwapCells(fromCell, toCell))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Cannot swap {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;            &#10;            // Geçici swap yap ve match kontrol et&#10;            SwapCellData(fromCell, toCell);&#10;            &#10;            bool hasMatches = CheckForMatches(fromPos) || CheckForMatches(toPos);&#10;            &#10;            if (hasMatches)&#10;            {&#10;                Debug.Log($&quot;Swap successful: {fromPos} &lt;-&gt; {toPos}&quot;);&#10;                &#10;                // Animasyonlu swap gerçekleştir&#10;                PerformAnimatedSwap(fromCell, toCell);&#10;                &#10;                // Sadece swap yapılan cell'lerden etkilenen eşleşmeleri bul ve animasyon tetikle&#10;                TriggerMatchAnimationsForSwappedCells(fromCell, toCell);&#10;                &#10;                return true;&#10;            }&#10;            else&#10;            {&#10;                // Match bulunamadı, swap'i geri al&#10;                SwapCellData(fromCell, toCell);&#10;                &#10;                // Swap yapılmaya çalışılan cell'lerde WrongMatch animasyonu tetikle&#10;                fromCell.TriggerWrongMatchAnimation();&#10;                toCell.TriggerWrongMatchAnimation();&#10;                &#10;                Debug.Log($&quot;Swap failed: No matches found after swapping {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Sadece swap yapılan cell'lerden etkilenen eşleşmeleri bulur ve animasyon tetikler&#10;        /// &lt;/summary&gt;&#10;        private void TriggerMatchAnimationsForSwappedCells(CellController cell1, CellController cell2)&#10;        {&#10;            List&lt;CellController&gt; allMatchedCells = new List&lt;CellController&gt;();&#10;            &#10;            // Cell1'den etkilenen eşleşmeleri bul&#10;            List&lt;CellController&gt; cell1Matches = GetMatchedCellsAtPosition(cell1.GridPosition);&#10;            foreach (var cell in cell1Matches)&#10;            {&#10;                if (!allMatchedCells.Contains(cell))&#10;                {&#10;                    allMatchedCells.Add(cell);&#10;                }&#10;            }&#10;            &#10;            // Cell2'den etkilenen eşleşmeleri bul&#10;            List&lt;CellController&gt; cell2Matches = GetMatchedCellsAtPosition(cell2.GridPosition);&#10;            foreach (var cell in cell2Matches)&#10;            {&#10;                if (!allMatchedCells.Contains(cell))&#10;                {&#10;                    allMatchedCells.Add(cell);&#10;                }&#10;            }&#10;            &#10;            // Debug log ile eşleşen cell'lerin listesini yazdır&#10;            Debug.Log($&quot;=== SWAP MATCH RESULTS ===&quot;);&#10;            Debug.Log($&quot;Swapped cells: {cell1.GridPosition} &lt;-&gt; {cell2.GridPosition}&quot;);&#10;            Debug.Log($&quot;Cell1 matches: {cell1Matches.Count}&quot;);&#10;            Debug.Log($&quot;Cell2 matches: {cell2Matches.Count}&quot;);&#10;            Debug.Log($&quot;Total unique matches: {allMatchedCells.Count}&quot;);&#10;            &#10;            string matchList = &quot;Matched positions: &quot;;&#10;            foreach (var cell in allMatchedCells)&#10;            {&#10;                matchList += $&quot;{cell.GridPosition} &quot;;&#10;            }&#10;            Debug.Log(matchList);&#10;            &#10;            // Eşleşen tüm cell'lerde Match animasyonu tetikle&#10;            foreach (var cell in allMatchedCells)&#10;            {&#10;                cell.TriggerMatchAnimation();&#10;            }&#10;            &#10;            Debug.Log($&quot;Match animations triggered for {allMatchedCells.Count} cells affected by swap&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Grid'deki tüm eşleşmeleri bulur ve Match animasyonu tetikler&#10;        /// &lt;/summary&gt;&#10;        private void TriggerMatchAnimationsForAllMatches()&#10;        {&#10;            List&lt;CellController&gt; matchedCells = new List&lt;CellController&gt;();&#10;            &#10;            if (Cells == null) return;&#10;            &#10;            int gridSize = Cells.GetLength(0);&#10;            &#10;            // Tüm grid'i tara ve eşleşmeleri bul&#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                for (int col = 0; col &lt; gridSize; col++)&#10;                {&#10;                    Vector2Int position = new Vector2Int(col, row);&#10;                    &#10;                    if (CheckForMatches(position))&#10;                    {&#10;                        // Bu pozisyondaki eşleşmeleri bul ve listeye ekle&#10;                        List&lt;CellController&gt; positionMatches = GetMatchedCellsAtPosition(position);&#10;                        &#10;                        foreach (var cell in positionMatches)&#10;                        {&#10;                            if (!matchedCells.Contains(cell))&#10;                            {&#10;                                matchedCells.Add(cell);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Eşleşen tüm cell'lerde Match animasyonu tetikle&#10;            foreach (var cell in matchedCells)&#10;            {&#10;                cell.TriggerMatchAnimation();&#10;            }&#10;            &#10;            Debug.Log($&quot;Match animations triggered for {matchedCells.Count} cells&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda 3'lü match var mı kontrol eder (Sarmal/Dallanma yapısı)&#10;        /// &lt;/summary&gt;&#10;        private bool CheckForMatches(Vector2Int position)&#10;        {&#10;            if (!IsValidPosition(position)) return false;&#10;            &#10;            CellController cell = Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) return false;&#10;            &#10;            Color targetColor = cell.CellData.Piece.Color;&#10;            &#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul (sarmal yapı)&#10;            HashSet&lt;Vector2Int&gt; connectedCells = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedCells);&#10;            &#10;            // 3 veya daha fazla bağlı cell varsa match&#10;            return connectedCells.Count &gt;= 3;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Rekursif olarak bağlı tüm aynı renkli cell'leri bulur (sarmal yapı)&#10;        /// &lt;/summary&gt;&#10;        private void FindConnectedCells(Vector2Int position, Color targetColor, HashSet&lt;Vector2Int&gt; visited)&#10;        {&#10;            // Bu pozisyon zaten ziyaret edildiyse veya geçersizse dur&#10;            if (!IsValidPosition(position) || visited.Contains(position))&#10;                return;&#10;            &#10;            CellController cell = Cells[position.y, position.x];&#10;            &#10;            // Boş, duvar veya farklı renk ise dur&#10;            if (cell.IsEmpty() || cell.IsWall() || !ColorsMatch(cell.CellData.Piece.Color, targetColor))&#10;                return;&#10;            &#10;            // Bu pozisyonu ziyaret edildi olarak işaretle&#10;            visited.Add(position);&#10;            &#10;            // 4 yöne de (sağ, sol, yukarı, aşağı) rekursif olarak devam et&#10;            FindConnectedCells(position + Vector2Int.right, targetColor, visited); // Sağ&#10;            FindConnectedCells(position + Vector2Int.left, targetColor, visited);  // Sol&#10;            FindConnectedCells(position + Vector2Int.up, targetColor, visited);    // Yukarı&#10;            FindConnectedCells(position + Vector2Int.down, targetColor, visited);  // Aşağı&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyondaki tüm bağlı eşleşen cell'leri döndürür (sarmal yapı)&#10;        /// &lt;/summary&gt;&#10;        private List&lt;CellController&gt; GetMatchedCellsAtPosition(Vector2Int position)&#10;        {&#10;            List&lt;CellController&gt; matchedCells = new List&lt;CellController&gt;();&#10;            &#10;            if (!IsValidPosition(position)) return matchedCells;&#10;            &#10;            CellController cell = Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) &#10;                return matchedCells;&#10;            &#10;            Color targetColor = cell.CellData.Piece.Color;&#10;            &#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul&#10;            HashSet&lt;Vector2Int&gt; connectedPositions = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedPositions);&#10;            &#10;            // 3 veya daha fazla bağlı cell varsa listeye ekle&#10;            if (connectedPositions.Count &gt;= 3)&#10;            {&#10;                foreach (var pos in connectedPositions)&#10;                {&#10;                    matchedCells.Add(Cells[pos.y, pos.x]);&#10;                }&#10;            }&#10;            &#10;            return matchedCells;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki cell arasında animasyonlı swap gerçekleştirir&#10;        /// &lt;/summary&gt;&#10;        private void PerformAnimatedSwap(CellController cell1, CellController cell2)&#10;        {&#10;            Vector3 cell1Position = cell1.transform.position;&#10;            Vector3 cell2Position = cell2.transform.position;&#10;            &#10;            // Her iki cell'i de karşı pozisyona animasyonla götür&#10;            cell1.MoveTo(cell2Position);&#10;            cell2.MoveTo(cell1Position);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki cell'in swap edilip edilemeyeceğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool CanSwapCells(CellController fromCell, CellController toCell)&#10;        {&#10;            // Null kontrolleri&#10;            if (fromCell == null || toCell == null) return false;&#10;            &#10;            // Wall kontrolü - Duvar ile hiçbir şey swap edilemez&#10;            if (fromCell.IsWall() || toCell.IsWall())&#10;            {&#10;                return false;&#10;            }&#10;            &#10;            // En az bir cell'de piece olmalı&#10;            if (fromCell.IsEmpty() &amp;&amp; toCell.IsEmpty())&#10;            {&#10;                return false;&#10;            }&#10;            &#10;            return true;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki cell'in data'larını swap eder&#10;        /// &lt;/summary&gt;&#10;        private void SwapCellData(CellController cell1, CellController cell2)&#10;        {&#10;            var cell1Position = cell1.GridPosition;&#10;            var cell2Position = cell2.GridPosition;&#10;           &#10;            // Grid'deki cell'lerin pozisyonlarını güncelle&#10;            Cells[cell1Position.y, cell1Position.x] = cell2;&#10;            Cells[cell2Position.y, cell2Position.x] = cell1;&#10;            // Cell'lerin grid pozisyonlarını güncelle&#10;            cell1.GridPosition = cell2Position;&#10;            cell2.GridPosition = cell1Position;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// İki rengin eşleşip eşleşmediğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool ColorsMatch(Color color1, Color color2)&#10;        {&#10;            // Renk karşılaştırması için epsilon değeri kullan&#10;            float threshold = 0.1f;&#10;            return Mathf.Abs(color1.r - color2.r) &lt; threshold &amp;&amp;&#10;                   Mathf.Abs(color1.g - color2.g) &lt; threshold &amp;&amp;&#10;                   Mathf.Abs(color1.b - color2.b) &lt; threshold;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Pozisyonun grid sınırları içinde olup olmadığını kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool IsValidPosition(Vector2Int position)&#10;        {&#10;            if (Cells == null) return false;&#10;            &#10;            int gridSize = Cells.GetLength(0);&#10;            return position.x &gt;= 0 &amp;&amp; position.x &lt; gridSize &amp;&amp; &#10;                   position.y &gt;= 0 &amp;&amp; position.y &lt; gridSize;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/InputController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/InputController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    public class InputController : MonoBehaviour&#10;    {&#10;        [SerializeField] private float minSwipeDistance = 50f;&#10;        [SerializeField] private GridController gridController;&#10;        &#10;        private Vector2 startTouchPosition;&#10;        private Vector2 endTouchPosition;&#10;        private bool isTouching = false;&#10;        private CellController selectedCell;&#10;        &#10;        private void Start()&#10;        {&#10;            if (gridController == null)&#10;                gridController = FindObjectOfType&lt;GridController&gt;();&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            HandleInput();&#10;        }&#10;        &#10;        private void HandleInput()&#10;        {&#10;            // Mouse/Touch input handling&#10;            if (Input.GetMouseButtonDown(0))&#10;            {&#10;                startTouchPosition = Input.mousePosition;&#10;                isTouching = true;&#10;                &#10;                // Hangi cell'e dokunulduğunu bul&#10;                selectedCell = GetCellAtPosition(Camera.main.ScreenToWorldPoint(Input.mousePosition));&#10;            }&#10;            else if (Input.GetMouseButtonUp(0) &amp;&amp; isTouching)&#10;            {&#10;                endTouchPosition = Input.mousePosition;&#10;                isTouching = false;&#10;                &#10;                DetectSwipe();&#10;            }&#10;        }&#10;        &#10;        private CellController GetCellAtPosition(Vector3 worldPosition)&#10;        {&#10;            RaycastHit2D hit = Physics2D.Raycast(worldPosition, Vector2.zero);&#10;            if (hit.collider != null)&#10;            {&#10;                return hit.collider.GetComponent&lt;CellController&gt;();&#10;            }&#10;            return null;&#10;        }&#10;        &#10;        private void DetectSwipe()&#10;        {&#10;            if (selectedCell == null) return;&#10;            &#10;            Vector2 swipeVector = endTouchPosition - startTouchPosition;&#10;            float swipeDistance = swipeVector.magnitude;&#10;            &#10;            if (swipeDistance &lt; minSwipeDistance) return;&#10;            &#10;            Vector2Int swipeDirection = GetSwipeDirection(swipeVector);&#10;            &#10;            // GridController'a swipe isteği gönder&#10;            if (gridController != null)&#10;            {&#10;                gridController.TrySwap(selectedCell, swipeDirection);&#10;            }&#10;        }&#10;        &#10;        private Vector2Int GetSwipeDirection(Vector2 swipeVector)&#10;        {&#10;            Vector2 normalizedSwipe = swipeVector.normalized;&#10;            &#10;            if (Mathf.Abs(normalizedSwipe.x) &gt; Mathf.Abs(normalizedSwipe.y))&#10;            {&#10;                // Horizontal swipe&#10;                return normalizedSwipe.x &gt; 0 ? Vector2Int.right : Vector2Int.left;&#10;            }&#10;            else&#10;            {&#10;                // Vertical swipe&#10;                return normalizedSwipe.y &gt; 0 ? Vector2Int.up : Vector2Int.down;&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    public class InputController : MonoBehaviour&#10;    {&#10;        [SerializeField] private float minSwipeDistance = 50f;&#10;        [SerializeField] private GridController gridController;&#10;        &#10;        private Vector2 startTouchPosition;&#10;        private Vector2 endTouchPosition;&#10;        private bool isTouching = false;&#10;        private CellController selectedCell;&#10;        &#10;        private void Start()&#10;        {&#10;            if (gridController == null)&#10;                gridController = FindObjectOfType&lt;GridController&gt;();&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            HandleInput();&#10;        }&#10;        &#10;        private void HandleInput()&#10;        {&#10;            // Mouse/Touch input handling&#10;            if (Input.GetMouseButtonDown(0))&#10;            {&#10;                startTouchPosition = Input.mousePosition;&#10;                isTouching = true;&#10;                &#10;                // Hangi cell'e dokunulduğunu bul&#10;                selectedCell = GetCellAtPosition(Camera.main.ScreenToWorldPoint(Input.mousePosition));&#10;            }&#10;            else if (Input.GetMouseButtonUp(0) &amp;&amp; isTouching)&#10;            {&#10;                endTouchPosition = Input.mousePosition;&#10;                isTouching = false;&#10;                &#10;                DetectSwipe();&#10;            }&#10;        }&#10;        &#10;        private CellController GetCellAtPosition(Vector3 worldPosition)&#10;        {&#10;            RaycastHit2D hit = Physics2D.Raycast(worldPosition, Vector2.zero);&#10;            if (hit.collider != null)&#10;            {&#10;                return hit.collider.GetComponent&lt;CellController&gt;();&#10;            }&#10;            return null;&#10;        }&#10;        &#10;        private void DetectSwipe()&#10;        {&#10;            if (selectedCell == null) return;&#10;            &#10;            Vector2 swipeVector = endTouchPosition - startTouchPosition;&#10;            float swipeDistance = swipeVector.magnitude;&#10;            &#10;            if (swipeDistance &lt; minSwipeDistance) return;&#10;            &#10;            Vector2Int swipeDirection = GetSwipeDirection(swipeVector);&#10;            &#10;            // GridController'a swipe isteği gönder&#10;            if (gridController != null)&#10;            {&#10;                gridController.TrySwap(selectedCell, swipeDirection);&#10;            }&#10;        }&#10;        &#10;        private Vector2Int GetSwipeDirection(Vector2 swipeVector)&#10;        {&#10;            Vector2 normalizedSwipe = swipeVector.normalized;&#10;            &#10;            if (Mathf.Abs(normalizedSwipe.x) &gt; Mathf.Abs(normalizedSwipe.y))&#10;            {&#10;                // Horizontal swipe&#10;                return normalizedSwipe.x &gt; 0 ? Vector2Int.right : Vector2Int.left;&#10;            }&#10;            else&#10;            {&#10;                // Vertical swipe - Unity screen koordinatlarında Y yukarı pozitif&#10;                // Ama bizim grid sistemimizde Y aşağı pozitif&#10;                return normalizedSwipe.y &gt; 0 ? Vector2Int.down : Vector2Int.up;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System;&#10;using MiniGameFramework.Core;&#10;using MiniGameFramework.Events;&#10;&#10;namespace MiniGameFramework.Match3&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#10;    /// Extends MiniGameBase for framework integration&#10;    /// &lt;/summary&gt;&#10;    public class Match3Game : MiniGameBase&#10;    {&#10;        [Header(&quot;Game Configuration&quot;)]&#10;        [SerializeField] private int targetScore = 1000;&#10;        [SerializeField] private int movesLimit = 30;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#10;        &#10;        [Header(&quot;System References&quot;)]&#10;        [SerializeField] private GridManager gridManager;&#10;        [SerializeField] private InputHandler inputHandler;&#10;        [SerializeField] private SwapHandler swapHandler;&#10;        [SerializeField] private MatchFinder matchFinder;&#10;        [SerializeField] private RefillSystem refillSystem;&#10;        &#10;        // Game state&#10;        private int movesRemaining;&#10;        private int cascadeLevel;&#10;        private bool isProcessingMatches;&#10;        private GameState gameState;&#10;        &#10;        // Additional events specific to Match-3&#10;        public event Action&lt;int&gt; OnMovesChanged;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#10;        public event Action OnCascadeStarted;&#10;        public event Action OnCascadeEnded;&#10;        &#10;        // IMiniGame Implementation&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#10;        public bool IsInitialized { get; private set; }&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#10;&#10;        // Events&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#10;&#10;        // Properties&#10;        public int CurrentScore =&gt; currentScore;&#10;        public int MovesRemaining =&gt; movesRemaining;&#10;        public int TargetScore =&gt; targetScore;&#10;        public GameState State =&gt; gameState;&#10;        &#10;        private void Awake()&#10;        {&#10;            ValidateComponents();&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        private void ValidateComponents()&#10;        {&#10;            if (gridManager == null) gridManager = GetComponent&lt;GridManager&gt;();&#10;            if (inputHandler == null) inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            if (swapHandler == null) swapHandler = GetComponent&lt;SwapHandler&gt;();&#10;            if (matchFinder == null) matchFinder = GetComponent&lt;MatchFinder&gt;();&#10;            if (refillSystem == null) refillSystem = GetComponent&lt;RefillSystem&gt;();&#10;        }&#10;        &#10;        #region MiniGameBase Overrides&#10;        &#10;        protected override void OnInitialize()&#10;        {&#10;            // Initialize all systems&#10;            matchFinder.Initialize(gridManager);&#10;            swapHandler.Initialize(gridManager, matchFinder);&#10;            inputHandler.Initialize(gridManager, swapHandler);&#10;            refillSystem.Initialize(gridManager);&#10;            &#10;            // Subscribe to events&#10;            SubscribeToEvents();&#10;            &#10;            // Setup initial grid&#10;            refillSystem.InitialFillGrid();&#10;            &#10;            // Ensure no initial matches&#10;            StartCoroutine(ClearInitialMatches());&#10;        }&#10;        &#10;        protected override void OnGameStart()&#10;        {&#10;            // Reset game state&#10;            movesRemaining = movesLimit;&#10;            cascadeLevel = 0;&#10;            isProcessingMatches = false;&#10;            &#10;            // Enable input&#10;            inputHandler.SetInputEnabled(true);&#10;            &#10;            gameState = GameState.Playing;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            &#10;            // Publish game started event&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Ready, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGamePause()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Paused;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Paused));&#10;        }&#10;        &#10;        protected override void OnGameResume()&#10;        {&#10;            inputHandler.SetInputEnabled(true);&#10;            gameState = GameState.Playing;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Paused, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGameEnd()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Ended;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Ended));&#10;        }&#10;        &#10;        protected override void OnCleanup()&#10;        {&#10;            UnsubscribeFromEvents();&#10;            &#10;            if (gridManager != null)&#10;                gridManager.ClearGrid();&#10;&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Event Handling&#10;        &#10;        private void SubscribeToEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted += OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted += OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted -= OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted -= OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void OnSwapCompleted(Vector2Int pos1, Vector2Int pos2, bool wasSuccessful)&#10;        {&#10;            if (!IsGameActive()) return;&#10;            &#10;            // Publish swap event&#10;            Events.Events.Publish(new PieceSwappedEvent(pos1, pos2, wasSuccessful));&#10;            &#10;            if (wasSuccessful)&#10;            {&#10;                // Consume a move&#10;                movesRemaining--;&#10;                OnMovesChanged?.Invoke(movesRemaining);&#10;                Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;                &#10;                // Start cascade processing&#10;                StartCoroutine(ProcessMatches());&#10;                &#10;                // Check for game over conditions&#10;                if (movesRemaining &lt;= 0)&#10;                {&#10;                    StartCoroutine(CheckGameOverAfterCascade());&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void OnRefillCompleted()&#10;        {&#10;            if (!IsPlaying) return;&#10;            &#10;            // Check for new matches after refill&#10;            StartCoroutine(ProcessMatches());&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Match Processing and Cascades&#10;        &#10;        private IEnumerator ProcessMatches()&#10;        {&#10;            if (isProcessingMatches) yield break;&#10;            &#10;            isProcessingMatches = true;&#10;            cascadeLevel = 0;&#10;            int totalCascadeScore = 0;&#10;            &#10;            OnCascadeStarted?.Invoke();&#10;            Events.Events.Publish(new CascadeStartedEvent(cascadeLevel));&#10;            &#10;            bool foundMatches;&#10;            do&#10;            {&#10;                cascadeLevel++;&#10;                &#10;                // Find all matches&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                foundMatches = matches.Count &gt; 0;&#10;                &#10;                if (foundMatches)&#10;                {&#10;                    // Process matches and get the score for this cascade&#10;                    int cascadeScore = ProcessMatchedPieces(matches);&#10;                    totalCascadeScore += cascadeScore;&#10;&#10;                    // Wait for destruction animations to complete&#10;                    yield return new WaitForSeconds(0.5f);&#10;                    &#10;                    // Apply gravity and refill&#10;                    yield return StartCoroutine(refillSystem.RefillGrid());&#10;                    &#10;                    // Wait before checking for new matches&#10;                    yield return new WaitForSeconds(cascadeDelay);&#10;                }&#10;                &#10;            } while (foundMatches);&#10;            &#10;            isProcessingMatches = false;&#10;            OnCascadeEnded?.Invoke();&#10;            Events.Events.Publish(new CascadeEndedEvent(cascadeLevel - 1, totalCascadeScore));&#10;        }&#10;        &#10;        private int ProcessMatchedPieces(List&lt;List&lt;Vector2Int&gt;&gt; matches)&#10;        {&#10;            List&lt;Piece&gt; matchedPieces = new List&lt;Piece&gt;();&#10;            int matchScore = 0;&#10;            &#10;            foreach (var match in matches)&#10;            {&#10;                int matchValue = 0;&#10;                List&lt;Vector2Int&gt; matchPositions = new List&lt;Vector2Int&gt;();&#10;                &#10;                foreach (var position in match)&#10;                {&#10;                    Piece piece = gridManager.GetPiece(position);&#10;                    if (piece != null &amp;&amp; !matchedPieces.Contains(piece))&#10;                    {&#10;                        matchedPieces.Add(piece);&#10;                        matchPositions.Add(position);&#10;                        &#10;                        int pieceScore = piece.GetScore();&#10;                        // Apply cascade multiplier&#10;                        pieceScore *= cascadeLevel;&#10;                        matchValue += pieceScore;&#10;                        &#10;                        // Handle special pieces&#10;                        if (piece.IsSpecial)&#10;                        {&#10;                            piece.ActivateSpecialEffect(position);&#10;                            int specialScore = piece.GetScore(true) * cascadeLevel;&#10;                            matchValue += specialScore;&#10;                            &#10;                            // Publish special piece event&#10;                            Events.Events.Publish(new SpecialPieceActivatedEvent(position, piece.SpecialType, new List&lt;Vector2Int&gt; { position }));&#10;                        }&#10;                        &#10;                        // Trigger match notification&#10;                        piece.OnMatched();&#10;                        &#10;                        // Remove from grid&#10;                        gridManager.RemovePiece(position);&#10;                        &#10;                        // Destroy piece&#10;                        piece.Destroy();&#10;                    }&#10;                }&#10;                &#10;                // Publish match found event&#10;                if (matchPositions.Count &gt; 0)&#10;                {&#10;                    Events.Events.Publish(new MatchFoundEvent(matchPositions, matchValue));&#10;                }&#10;                &#10;                matchScore += matchValue;&#10;            }&#10;            &#10;            // Add score using base class method&#10;            AddScore(matchScore);&#10;            &#10;            OnPiecesMatched?.Invoke(matchedPieces);&#10;            &#10;            return matchScore;&#10;        }&#10;        &#10;        private IEnumerator ClearInitialMatches()&#10;        {&#10;            // Keep clearing matches until no more exist&#10;            while (true)&#10;            {&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                if (matches.Count == 0) break;&#10;                &#10;                // Destroy matched pieces without scoring&#10;                foreach (var match in matches)&#10;                {&#10;                    foreach (var position in match)&#10;                    {&#10;                        Piece piece = gridManager.GetPiece(position);&#10;                        if (piece != null)&#10;                        {&#10;                            gridManager.RemovePiece(position);&#10;                            Destroy(piece.gameObject);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Refill and check again&#10;                yield return StartCoroutine(refillSystem.RefillGrid());&#10;                yield return new WaitForSeconds(0.1f);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Game Over Logic&#10;        &#10;        private IEnumerator CheckGameOverAfterCascade()&#10;        {&#10;            // Wait for current cascade to finish&#10;            while (isProcessingMatches || refillSystem.IsRefilling)&#10;            {&#10;                yield return null;&#10;            }&#10;            &#10;            CheckGameOverConditions();&#10;        }&#10;        &#10;        private void CheckGameOverConditions()&#10;        {&#10;            // Check win condition&#10;            if (currentScore &gt;= targetScore)&#10;            {&#10;                EndGame();&#10;                return;&#10;            }&#10;            &#10;            // Check loss conditions&#10;            if (movesRemaining &lt;= 0)&#10;            {&#10;                // Check if there are still possible moves&#10;                if (!matchFinder.HasPossibleMoves())&#10;                {&#10;                    EndGame();&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Public Interface&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus moves (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public void AddMoves(int moves)&#10;        {&#10;            movesRemaining += moves;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus score (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public new void AddScore(int score)&#10;        {&#10;            base.AddScore(score);&#10;            Events.Events.Publish(new ScoreUpdatedEvent(currentScore, score));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if the game can continue&#10;        /// &lt;/summary&gt;&#10;        public bool CanContinue()&#10;        {&#10;            return movesRemaining &gt; 0 &amp;&amp; matchFinder.HasPossibleMoves();&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Represents the current state of the Match-3 game&#10;    /// &lt;/summary&gt;&#10;    public enum GameState&#10;    {&#10;        NotInitialized,&#10;        Ready,&#10;        Playing,&#10;        Paused,&#10;        Ended&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using System.Collections;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System;&#13;&#10;using MiniGameFramework.Core;&#13;&#10;using MiniGameFramework.Events;&#13;&#10;&#13;&#10;namespace MiniGameFramework.Match3&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#13;&#10;    /// Extends MiniGameBase for framework integration&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public class Match3Game : MiniGameBase&#13;&#10;    {&#13;&#10;        [Header(&quot;Game Configuration&quot;)]&#13;&#10;        [SerializeField] private int targetScore = 1000;&#13;&#10;        [SerializeField] private int movesLimit = 30;&#13;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;System References&quot;)]&#13;&#10;        [SerializeField] private GridManager gridManager;&#13;&#10;        [SerializeField] private InputHandler inputHandler;&#13;&#10;        [SerializeField] private SwapHandler swapHandler;&#13;&#10;        [SerializeField] private MatchFinder matchFinder;&#13;&#10;        [SerializeField] private RefillSystem refillSystem;&#13;&#10;        &#13;&#10;        // Game state&#13;&#10;        private int _currentScore;&#13;&#10;        private int movesRemaining;&#13;&#10;        private int cascadeLevel;&#13;&#10;        private bool isProcessingMatches;&#13;&#10;        private GameState gameState;&#13;&#10;        &#13;&#10;        // Additional events specific to Match-3&#13;&#10;        public event Action&lt;int&gt; OnMovesChanged;&#13;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#13;&#10;        public event Action OnCascadeStarted;&#13;&#10;        public event Action OnCascadeEnded;&#13;&#10;        &#13;&#10;        // IMiniGame Implementation&#13;&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#13;&#10;        public bool IsInitialized { get; private set; }&#13;&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#13;&#10;&#13;&#10;        // Events&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#13;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#13;&#10;&#13;&#10;        // Properties&#13;&#10;        public int CurrentScore =&gt; _currentScore;&#13;&#10;        public int MovesRemaining =&gt; movesRemaining;&#13;&#10;        public int TargetScore =&gt; targetScore;&#13;&#10;        public GameState State =&gt; gameState;&#13;&#10;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public enum GameState&#13;&#10;    {&#13;&#10;        Initializing,&#13;&#10;        Ready,&#13;&#10;        Playing,&#13;&#10;        Paused,&#13;&#10;        GameOver&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>