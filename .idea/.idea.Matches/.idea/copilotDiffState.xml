<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/CollectibleTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/CollectibleTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct CollectibleTriggeredEvent&#10;    {&#10;        public InteractableObjectController CollectibleObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/FinishLineTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/FinishLineTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct FinishLineTriggeredEvent&#10;    {&#10;        public InteractableObjectController FinishLineObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/ObstacleTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/ObstacleTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct ObstacleTriggeredEvent&#10;    {&#10;        public InteractableObjectController ObstacleObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs" />
              <option name="updatedContent" value="namespace Core&#10;{&#10;    public interface ILevel&#10;    {&#10;        void Load();&#10;        void Unload();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core&#10;{&#10;    public class Level : MonoBehaviour, ILevel&#10;    {&#10;        [SerializeField] private string levelName;&#10;        [SerializeField] private bool isLoaded;&#10;        &#10;        public string LevelName =&gt; levelName;&#10;        public bool IsLoaded =&gt; isLoaded;&#10;        &#10;        public virtual void Load()&#10;        {&#10;            if (!isLoaded)&#10;            {&#10;                OnLevelLoad();&#10;                isLoaded = true;&#10;                Debug.Log($&quot;Level {levelName} loaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        public virtual void Unload()&#10;        {&#10;            if (isLoaded)&#10;            {&#10;                OnLevelUnload();&#10;                isLoaded = false;&#10;                Debug.Log($&quot;Level {levelName} unloaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        // Override edilebilir metodlar&#10;        protected virtual void OnLevelLoad()&#10;        {&#10;            // Level yüklenirken yapılacak işlemler&#10;        }&#10;        &#10;        protected virtual void OnLevelUnload()&#10;        {&#10;            // Level boşaltılırken yapılacak işlemler&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            if (string.IsNullOrEmpty(levelName))&#10;            {&#10;                levelName = gameObject.name;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System;&#10;using MiniGameFramework.Core;&#10;using MiniGameFramework.Events;&#10;&#10;namespace MiniGameFramework.Match3&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#10;    /// Extends MiniGameBase for framework integration&#10;    /// &lt;/summary&gt;&#10;    public class Match3Game : MiniGameBase&#10;    {&#10;        [Header(&quot;Game Configuration&quot;)]&#10;        [SerializeField] private int targetScore = 1000;&#10;        [SerializeField] private int movesLimit = 30;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#10;        &#10;        [Header(&quot;System References&quot;)]&#10;        [SerializeField] private GridManager gridManager;&#10;        [SerializeField] private InputHandler inputHandler;&#10;        [SerializeField] private SwapHandler swapHandler;&#10;        [SerializeField] private MatchFinder matchFinder;&#10;        [SerializeField] private RefillSystem refillSystem;&#10;        &#10;        // Game state&#10;        private int movesRemaining;&#10;        private int cascadeLevel;&#10;        private bool isProcessingMatches;&#10;        private GameState gameState;&#10;        &#10;        // Additional events specific to Match-3&#10;        public event Action&lt;int&gt; OnMovesChanged;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#10;        public event Action OnCascadeStarted;&#10;        public event Action OnCascadeEnded;&#10;        &#10;        // IMiniGame Implementation&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#10;        public bool IsInitialized { get; private set; }&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#10;&#10;        // Events&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#10;&#10;        // Properties&#10;        public int CurrentScore =&gt; currentScore;&#10;        public int MovesRemaining =&gt; movesRemaining;&#10;        public int TargetScore =&gt; targetScore;&#10;        public GameState State =&gt; gameState;&#10;        &#10;        private void Awake()&#10;        {&#10;            ValidateComponents();&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        private void ValidateComponents()&#10;        {&#10;            if (gridManager == null) gridManager = GetComponent&lt;GridManager&gt;();&#10;            if (inputHandler == null) inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            if (swapHandler == null) swapHandler = GetComponent&lt;SwapHandler&gt;();&#10;            if (matchFinder == null) matchFinder = GetComponent&lt;MatchFinder&gt;();&#10;            if (refillSystem == null) refillSystem = GetComponent&lt;RefillSystem&gt;();&#10;        }&#10;        &#10;        #region MiniGameBase Overrides&#10;        &#10;        protected override void OnInitialize()&#10;        {&#10;            // Initialize all systems&#10;            matchFinder.Initialize(gridManager);&#10;            swapHandler.Initialize(gridManager, matchFinder);&#10;            inputHandler.Initialize(gridManager, swapHandler);&#10;            refillSystem.Initialize(gridManager);&#10;            &#10;            // Subscribe to events&#10;            SubscribeToEvents();&#10;            &#10;            // Setup initial grid&#10;            refillSystem.InitialFillGrid();&#10;            &#10;            // Ensure no initial matches&#10;            StartCoroutine(ClearInitialMatches());&#10;        }&#10;        &#10;        protected override void OnGameStart()&#10;        {&#10;            // Reset game state&#10;            movesRemaining = movesLimit;&#10;            cascadeLevel = 0;&#10;            isProcessingMatches = false;&#10;            &#10;            // Enable input&#10;            inputHandler.SetInputEnabled(true);&#10;            &#10;            gameState = GameState.Playing;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            &#10;            // Publish game started event&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Ready, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGamePause()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Paused;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Paused));&#10;        }&#10;        &#10;        protected override void OnGameResume()&#10;        {&#10;            inputHandler.SetInputEnabled(true);&#10;            gameState = GameState.Playing;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Paused, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGameEnd()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Ended;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Ended));&#10;        }&#10;        &#10;        protected override void OnCleanup()&#10;        {&#10;            UnsubscribeFromEvents();&#10;            &#10;            if (gridManager != null)&#10;                gridManager.ClearGrid();&#10;&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Event Handling&#10;        &#10;        private void SubscribeToEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted += OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted += OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted -= OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted -= OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void OnSwapCompleted(Vector2Int pos1, Vector2Int pos2, bool wasSuccessful)&#10;        {&#10;            if (!IsGameActive()) return;&#10;            &#10;            // Publish swap event&#10;            Events.Events.Publish(new PieceSwappedEvent(pos1, pos2, wasSuccessful));&#10;            &#10;            if (wasSuccessful)&#10;            {&#10;                // Consume a move&#10;                movesRemaining--;&#10;                OnMovesChanged?.Invoke(movesRemaining);&#10;                Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;                &#10;                // Start cascade processing&#10;                StartCoroutine(ProcessMatches());&#10;                &#10;                // Check for game over conditions&#10;                if (movesRemaining &lt;= 0)&#10;                {&#10;                    StartCoroutine(CheckGameOverAfterCascade());&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void OnRefillCompleted()&#10;        {&#10;            if (!IsPlaying) return;&#10;            &#10;            // Check for new matches after refill&#10;            StartCoroutine(ProcessMatches());&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Match Processing and Cascades&#10;        &#10;        private IEnumerator ProcessMatches()&#10;        {&#10;            if (isProcessingMatches) yield break;&#10;            &#10;            isProcessingMatches = true;&#10;            cascadeLevel = 0;&#10;            int totalCascadeScore = 0;&#10;            &#10;            OnCascadeStarted?.Invoke();&#10;            Events.Events.Publish(new CascadeStartedEvent(cascadeLevel));&#10;            &#10;            bool foundMatches;&#10;            do&#10;            {&#10;                cascadeLevel++;&#10;                &#10;                // Find all matches&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                foundMatches = matches.Count &gt; 0;&#10;                &#10;                if (foundMatches)&#10;                {&#10;                    // Process matches and get the score for this cascade&#10;                    int cascadeScore = ProcessMatchedPieces(matches);&#10;                    totalCascadeScore += cascadeScore;&#10;&#10;                    // Wait for destruction animations to complete&#10;                    yield return new WaitForSeconds(0.5f);&#10;                    &#10;                    // Apply gravity and refill&#10;                    yield return StartCoroutine(refillSystem.RefillGrid());&#10;                    &#10;                    // Wait before checking for new matches&#10;                    yield return new WaitForSeconds(cascadeDelay);&#10;                }&#10;                &#10;            } while (foundMatches);&#10;            &#10;            isProcessingMatches = false;&#10;            OnCascadeEnded?.Invoke();&#10;            Events.Events.Publish(new CascadeEndedEvent(cascadeLevel - 1, totalCascadeScore));&#10;        }&#10;        &#10;        private int ProcessMatchedPieces(List&lt;List&lt;Vector2Int&gt;&gt; matches)&#10;        {&#10;            List&lt;Piece&gt; matchedPieces = new List&lt;Piece&gt;();&#10;            int matchScore = 0;&#10;            &#10;            foreach (var match in matches)&#10;            {&#10;                int matchValue = 0;&#10;                List&lt;Vector2Int&gt; matchPositions = new List&lt;Vector2Int&gt;();&#10;                &#10;                foreach (var position in match)&#10;                {&#10;                    Piece piece = gridManager.GetPiece(position);&#10;                    if (piece != null &amp;&amp; !matchedPieces.Contains(piece))&#10;                    {&#10;                        matchedPieces.Add(piece);&#10;                        matchPositions.Add(position);&#10;                        &#10;                        int pieceScore = piece.GetScore();&#10;                        // Apply cascade multiplier&#10;                        pieceScore *= cascadeLevel;&#10;                        matchValue += pieceScore;&#10;                        &#10;                        // Handle special pieces&#10;                        if (piece.IsSpecial)&#10;                        {&#10;                            piece.ActivateSpecialEffect(position);&#10;                            int specialScore = piece.GetScore(true) * cascadeLevel;&#10;                            matchValue += specialScore;&#10;                            &#10;                            // Publish special piece event&#10;                            Events.Events.Publish(new SpecialPieceActivatedEvent(position, piece.SpecialType, new List&lt;Vector2Int&gt; { position }));&#10;                        }&#10;                        &#10;                        // Trigger match notification&#10;                        piece.OnMatched();&#10;                        &#10;                        // Remove from grid&#10;                        gridManager.RemovePiece(position);&#10;                        &#10;                        // Destroy piece&#10;                        piece.Destroy();&#10;                    }&#10;                }&#10;                &#10;                // Publish match found event&#10;                if (matchPositions.Count &gt; 0)&#10;                {&#10;                    Events.Events.Publish(new MatchFoundEvent(matchPositions, matchValue));&#10;                }&#10;                &#10;                matchScore += matchValue;&#10;            }&#10;            &#10;            // Add score using base class method&#10;            AddScore(matchScore);&#10;            &#10;            OnPiecesMatched?.Invoke(matchedPieces);&#10;            &#10;            return matchScore;&#10;        }&#10;        &#10;        private IEnumerator ClearInitialMatches()&#10;        {&#10;            // Keep clearing matches until no more exist&#10;            while (true)&#10;            {&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                if (matches.Count == 0) break;&#10;                &#10;                // Destroy matched pieces without scoring&#10;                foreach (var match in matches)&#10;                {&#10;                    foreach (var position in match)&#10;                    {&#10;                        Piece piece = gridManager.GetPiece(position);&#10;                        if (piece != null)&#10;                        {&#10;                            gridManager.RemovePiece(position);&#10;                            Destroy(piece.gameObject);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Refill and check again&#10;                yield return StartCoroutine(refillSystem.RefillGrid());&#10;                yield return new WaitForSeconds(0.1f);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Game Over Logic&#10;        &#10;        private IEnumerator CheckGameOverAfterCascade()&#10;        {&#10;            // Wait for current cascade to finish&#10;            while (isProcessingMatches || refillSystem.IsRefilling)&#10;            {&#10;                yield return null;&#10;            }&#10;            &#10;            CheckGameOverConditions();&#10;        }&#10;        &#10;        private void CheckGameOverConditions()&#10;        {&#10;            // Check win condition&#10;            if (currentScore &gt;= targetScore)&#10;            {&#10;                EndGame();&#10;                return;&#10;            }&#10;            &#10;            // Check loss conditions&#10;            if (movesRemaining &lt;= 0)&#10;            {&#10;                // Check if there are still possible moves&#10;                if (!matchFinder.HasPossibleMoves())&#10;                {&#10;                    EndGame();&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Public Interface&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus moves (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public void AddMoves(int moves)&#10;        {&#10;            movesRemaining += moves;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus score (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public new void AddScore(int score)&#10;        {&#10;            base.AddScore(score);&#10;            Events.Events.Publish(new ScoreUpdatedEvent(currentScore, score));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if the game can continue&#10;        /// &lt;/summary&gt;&#10;        public bool CanContinue()&#10;        {&#10;            return movesRemaining &gt; 0 &amp;&amp; matchFinder.HasPossibleMoves();&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Represents the current state of the Match-3 game&#10;    /// &lt;/summary&gt;&#10;    public enum GameState&#10;    {&#10;        NotInitialized,&#10;        Ready,&#10;        Playing,&#10;        Paused,&#10;        Ended&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using System.Collections;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System;&#13;&#10;using MiniGameFramework.Core;&#13;&#10;using MiniGameFramework.Events;&#13;&#10;&#13;&#10;namespace MiniGameFramework.Match3&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#13;&#10;    /// Extends MiniGameBase for framework integration&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public class Match3Game : MiniGameBase&#13;&#10;    {&#13;&#10;        [Header(&quot;Game Configuration&quot;)]&#13;&#10;        [SerializeField] private int targetScore = 1000;&#13;&#10;        [SerializeField] private int movesLimit = 30;&#13;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;System References&quot;)]&#13;&#10;        [SerializeField] private GridManager gridManager;&#13;&#10;        [SerializeField] private InputHandler inputHandler;&#13;&#10;        [SerializeField] private SwapHandler swapHandler;&#13;&#10;        [SerializeField] private MatchFinder matchFinder;&#13;&#10;        [SerializeField] private RefillSystem refillSystem;&#13;&#10;        &#13;&#10;        // Game state&#13;&#10;        private int _currentScore;&#13;&#10;        private int movesRemaining;&#13;&#10;        private int cascadeLevel;&#13;&#10;        private bool isProcessingMatches;&#13;&#10;        private GameState gameState;&#13;&#10;        &#13;&#10;        // Additional events specific to Match-3&#13;&#10;        public event Action&lt;int&gt; OnMovesChanged;&#13;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#13;&#10;        public event Action OnCascadeStarted;&#13;&#10;        public event Action OnCascadeEnded;&#13;&#10;        &#13;&#10;        // IMiniGame Implementation&#13;&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#13;&#10;        public bool IsInitialized { get; private set; }&#13;&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#13;&#10;&#13;&#10;        // Events&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#13;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#13;&#10;&#13;&#10;        // Properties&#13;&#10;        public int CurrentScore =&gt; _currentScore;&#13;&#10;        public int MovesRemaining =&gt; movesRemaining;&#13;&#10;        public int TargetScore =&gt; targetScore;&#13;&#10;        public GameState State =&gt; gameState;&#13;&#10;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public enum GameState&#13;&#10;    {&#13;&#10;        Initializing,&#13;&#10;        Ready,&#13;&#10;        Playing,&#13;&#10;        Paused,&#13;&#10;        GameOver&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EditorTests.asmdef">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EditorTests.asmdef" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EventManagerTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/EventManagerTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelManagerTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelManagerTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/LevelTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/MathUtilityTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/MathUtilityTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/UIManagerTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Tests/Editor/UIManagerTests.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>