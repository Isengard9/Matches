<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/CollectibleTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/CollectibleTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct CollectibleTriggeredEvent&#10;    {&#10;        public InteractableObjectController CollectibleObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/FinishLineTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/FinishLineTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct FinishLineTriggeredEvent&#10;    {&#10;        public InteractableObjectController FinishLineObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/ObstacleTriggeredEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/RunnerCube/ObstacleTriggeredEvent.cs" />
              <option name="updatedContent" value="using MiniGames.RunnerCube.Core;&#10;&#10;namespace Core.Events.RunnerCube&#10;{&#10;    public struct ObstacleTriggeredEvent&#10;    {&#10;        public InteractableObjectController ObstacleObject;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs" />
              <option name="updatedContent" value="namespace Core&#10;{&#10;    public interface ILevel&#10;    {&#10;        void Load();&#10;        void Unload();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core&#10;{&#10;    public class Level : MonoBehaviour, ILevel&#10;    {&#10;        [SerializeField] private string levelName;&#10;        [SerializeField] private bool isLoaded;&#10;        &#10;        public string LevelName =&gt; levelName;&#10;        public bool IsLoaded =&gt; isLoaded;&#10;        &#10;        public virtual void Load()&#10;        {&#10;            if (!isLoaded)&#10;            {&#10;                OnLevelLoad();&#10;                isLoaded = true;&#10;                Debug.Log($&quot;Level {levelName} loaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        public virtual void Unload()&#10;        {&#10;            if (isLoaded)&#10;            {&#10;                OnLevelUnload();&#10;                isLoaded = false;&#10;                Debug.Log($&quot;Level {levelName} unloaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        // Override edilebilir metodlar&#10;        protected virtual void OnLevelLoad()&#10;        {&#10;            // Level yüklenirken yapılacak işlemler&#10;        }&#10;        &#10;        protected virtual void OnLevelUnload()&#10;        {&#10;            // Level boşaltılırken yapılacak işlemler&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            if (string.IsNullOrEmpty(levelName))&#10;            {&#10;                levelName = gameObject.name;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/UI/IMainButton.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/UI/IMainButton.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core.UI&#10;{&#10;    public interface IMainButton&#10;    {&#10;        void OnMainButtonClicked();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/UI/PanelController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/UI/PanelController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Core.UI&#10;{&#10;    public abstract class PanelController : MonoBehaviour, IMainButton&#10;    {&#10;        [SerializeField] protected Button mainButton;&#10;        [SerializeField] protected GameObject panel;&#10;&#10;        protected virtual void Awake()&#10;        {&#10;            if (mainButton != null)&#10;            {&#10;                mainButton.onClick.AddListener(OnMainButtonClicked);&#10;            }&#10;        }&#10;&#10;        protected virtual void OnDestroy()&#10;        {&#10;            if (mainButton != null)&#10;            {&#10;                mainButton.onClick.RemoveListener(OnMainButtonClicked);&#10;            }&#10;        }&#10;&#10;        public virtual void ShowPanel()&#10;        {&#10;            if (panel != null)&#10;            {&#10;                panel.SetActive(true);&#10;            }&#10;        }&#10;&#10;        public virtual void HidePanel()&#10;        {&#10;            if (panel != null)&#10;            {&#10;                panel.SetActive(false);&#10;            }&#10;        }&#10;&#10;        public virtual void OnMainButtonClicked()&#10;        {&#10;            HidePanel();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/UI/UIState.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/UI/UIState.cs" />
              <option name="updatedContent" value="namespace Core.UI&#10;{&#10;    public enum UIState&#10;    {&#10;        None,&#10;        StartPanel,&#10;        InGame,&#10;        EndPanel,&#10;        RestartPanel&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System;&#10;using MiniGameFramework.Core;&#10;using MiniGameFramework.Events;&#10;&#10;namespace MiniGameFramework.Match3&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#10;    /// Extends MiniGameBase for framework integration&#10;    /// &lt;/summary&gt;&#10;    public class Match3Game : MiniGameBase&#10;    {&#10;        [Header(&quot;Game Configuration&quot;)]&#10;        [SerializeField] private int targetScore = 1000;&#10;        [SerializeField] private int movesLimit = 30;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#10;        &#10;        [Header(&quot;System References&quot;)]&#10;        [SerializeField] private GridManager gridManager;&#10;        [SerializeField] private InputHandler inputHandler;&#10;        [SerializeField] private SwapHandler swapHandler;&#10;        [SerializeField] private MatchFinder matchFinder;&#10;        [SerializeField] private RefillSystem refillSystem;&#10;        &#10;        // Game state&#10;        private int movesRemaining;&#10;        private int cascadeLevel;&#10;        private bool isProcessingMatches;&#10;        private GameState gameState;&#10;        &#10;        // Additional events specific to Match-3&#10;        public event Action&lt;int&gt; OnMovesChanged;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#10;        public event Action OnCascadeStarted;&#10;        public event Action OnCascadeEnded;&#10;        &#10;        // IMiniGame Implementation&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#10;        public bool IsInitialized { get; private set; }&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#10;&#10;        // Events&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#10;&#10;        // Properties&#10;        public int CurrentScore =&gt; currentScore;&#10;        public int MovesRemaining =&gt; movesRemaining;&#10;        public int TargetScore =&gt; targetScore;&#10;        public GameState State =&gt; gameState;&#10;        &#10;        private void Awake()&#10;        {&#10;            ValidateComponents();&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        private void ValidateComponents()&#10;        {&#10;            if (gridManager == null) gridManager = GetComponent&lt;GridManager&gt;();&#10;            if (inputHandler == null) inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            if (swapHandler == null) swapHandler = GetComponent&lt;SwapHandler&gt;();&#10;            if (matchFinder == null) matchFinder = GetComponent&lt;MatchFinder&gt;();&#10;            if (refillSystem == null) refillSystem = GetComponent&lt;RefillSystem&gt;();&#10;        }&#10;        &#10;        #region MiniGameBase Overrides&#10;        &#10;        protected override void OnInitialize()&#10;        {&#10;            // Initialize all systems&#10;            matchFinder.Initialize(gridManager);&#10;            swapHandler.Initialize(gridManager, matchFinder);&#10;            inputHandler.Initialize(gridManager, swapHandler);&#10;            refillSystem.Initialize(gridManager);&#10;            &#10;            // Subscribe to events&#10;            SubscribeToEvents();&#10;            &#10;            // Setup initial grid&#10;            refillSystem.InitialFillGrid();&#10;            &#10;            // Ensure no initial matches&#10;            StartCoroutine(ClearInitialMatches());&#10;        }&#10;        &#10;        protected override void OnGameStart()&#10;        {&#10;            // Reset game state&#10;            movesRemaining = movesLimit;&#10;            cascadeLevel = 0;&#10;            isProcessingMatches = false;&#10;            &#10;            // Enable input&#10;            inputHandler.SetInputEnabled(true);&#10;            &#10;            gameState = GameState.Playing;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            &#10;            // Publish game started event&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Ready, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGamePause()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Paused;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Paused));&#10;        }&#10;        &#10;        protected override void OnGameResume()&#10;        {&#10;            inputHandler.SetInputEnabled(true);&#10;            gameState = GameState.Playing;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Paused, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGameEnd()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Ended;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Ended));&#10;        }&#10;        &#10;        protected override void OnCleanup()&#10;        {&#10;            UnsubscribeFromEvents();&#10;            &#10;            if (gridManager != null)&#10;                gridManager.ClearGrid();&#10;&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Event Handling&#10;        &#10;        private void SubscribeToEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted += OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted += OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted -= OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted -= OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void OnSwapCompleted(Vector2Int pos1, Vector2Int pos2, bool wasSuccessful)&#10;        {&#10;            if (!IsGameActive()) return;&#10;            &#10;            // Publish swap event&#10;            Events.Events.Publish(new PieceSwappedEvent(pos1, pos2, wasSuccessful));&#10;            &#10;            if (wasSuccessful)&#10;            {&#10;                // Consume a move&#10;                movesRemaining--;&#10;                OnMovesChanged?.Invoke(movesRemaining);&#10;                Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;                &#10;                // Start cascade processing&#10;                StartCoroutine(ProcessMatches());&#10;                &#10;                // Check for game over conditions&#10;                if (movesRemaining &lt;= 0)&#10;                {&#10;                    StartCoroutine(CheckGameOverAfterCascade());&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void OnRefillCompleted()&#10;        {&#10;            if (!IsPlaying) return;&#10;            &#10;            // Check for new matches after refill&#10;            StartCoroutine(ProcessMatches());&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Match Processing and Cascades&#10;        &#10;        private IEnumerator ProcessMatches()&#10;        {&#10;            if (isProcessingMatches) yield break;&#10;            &#10;            isProcessingMatches = true;&#10;            cascadeLevel = 0;&#10;            int totalCascadeScore = 0;&#10;            &#10;            OnCascadeStarted?.Invoke();&#10;            Events.Events.Publish(new CascadeStartedEvent(cascadeLevel));&#10;            &#10;            bool foundMatches;&#10;            do&#10;            {&#10;                cascadeLevel++;&#10;                &#10;                // Find all matches&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                foundMatches = matches.Count &gt; 0;&#10;                &#10;                if (foundMatches)&#10;                {&#10;                    // Process matches and get the score for this cascade&#10;                    int cascadeScore = ProcessMatchedPieces(matches);&#10;                    totalCascadeScore += cascadeScore;&#10;&#10;                    // Wait for destruction animations to complete&#10;                    yield return new WaitForSeconds(0.5f);&#10;                    &#10;                    // Apply gravity and refill&#10;                    yield return StartCoroutine(refillSystem.RefillGrid());&#10;                    &#10;                    // Wait before checking for new matches&#10;                    yield return new WaitForSeconds(cascadeDelay);&#10;                }&#10;                &#10;            } while (foundMatches);&#10;            &#10;            isProcessingMatches = false;&#10;            OnCascadeEnded?.Invoke();&#10;            Events.Events.Publish(new CascadeEndedEvent(cascadeLevel - 1, totalCascadeScore));&#10;        }&#10;        &#10;        private int ProcessMatchedPieces(List&lt;List&lt;Vector2Int&gt;&gt; matches)&#10;        {&#10;            List&lt;Piece&gt; matchedPieces = new List&lt;Piece&gt;();&#10;            int matchScore = 0;&#10;            &#10;            foreach (var match in matches)&#10;            {&#10;                int matchValue = 0;&#10;                List&lt;Vector2Int&gt; matchPositions = new List&lt;Vector2Int&gt;();&#10;                &#10;                foreach (var position in match)&#10;                {&#10;                    Piece piece = gridManager.GetPiece(position);&#10;                    if (piece != null &amp;&amp; !matchedPieces.Contains(piece))&#10;                    {&#10;                        matchedPieces.Add(piece);&#10;                        matchPositions.Add(position);&#10;                        &#10;                        int pieceScore = piece.GetScore();&#10;                        // Apply cascade multiplier&#10;                        pieceScore *= cascadeLevel;&#10;                        matchValue += pieceScore;&#10;                        &#10;                        // Handle special pieces&#10;                        if (piece.IsSpecial)&#10;                        {&#10;                            piece.ActivateSpecialEffect(position);&#10;                            int specialScore = piece.GetScore(true) * cascadeLevel;&#10;                            matchValue += specialScore;&#10;                            &#10;                            // Publish special piece event&#10;                            Events.Events.Publish(new SpecialPieceActivatedEvent(position, piece.SpecialType, new List&lt;Vector2Int&gt; { position }));&#10;                        }&#10;                        &#10;                        // Trigger match notification&#10;                        piece.OnMatched();&#10;                        &#10;                        // Remove from grid&#10;                        gridManager.RemovePiece(position);&#10;                        &#10;                        // Destroy piece&#10;                        piece.Destroy();&#10;                    }&#10;                }&#10;                &#10;                // Publish match found event&#10;                if (matchPositions.Count &gt; 0)&#10;                {&#10;                    Events.Events.Publish(new MatchFoundEvent(matchPositions, matchValue));&#10;                }&#10;                &#10;                matchScore += matchValue;&#10;            }&#10;            &#10;            // Add score using base class method&#10;            AddScore(matchScore);&#10;            &#10;            OnPiecesMatched?.Invoke(matchedPieces);&#10;            &#10;            return matchScore;&#10;        }&#10;        &#10;        private IEnumerator ClearInitialMatches()&#10;        {&#10;            // Keep clearing matches until no more exist&#10;            while (true)&#10;            {&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                if (matches.Count == 0) break;&#10;                &#10;                // Destroy matched pieces without scoring&#10;                foreach (var match in matches)&#10;                {&#10;                    foreach (var position in match)&#10;                    {&#10;                        Piece piece = gridManager.GetPiece(position);&#10;                        if (piece != null)&#10;                        {&#10;                            gridManager.RemovePiece(position);&#10;                            Destroy(piece.gameObject);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Refill and check again&#10;                yield return StartCoroutine(refillSystem.RefillGrid());&#10;                yield return new WaitForSeconds(0.1f);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Game Over Logic&#10;        &#10;        private IEnumerator CheckGameOverAfterCascade()&#10;        {&#10;            // Wait for current cascade to finish&#10;            while (isProcessingMatches || refillSystem.IsRefilling)&#10;            {&#10;                yield return null;&#10;            }&#10;            &#10;            CheckGameOverConditions();&#10;        }&#10;        &#10;        private void CheckGameOverConditions()&#10;        {&#10;            // Check win condition&#10;            if (currentScore &gt;= targetScore)&#10;            {&#10;                EndGame();&#10;                return;&#10;            }&#10;            &#10;            // Check loss conditions&#10;            if (movesRemaining &lt;= 0)&#10;            {&#10;                // Check if there are still possible moves&#10;                if (!matchFinder.HasPossibleMoves())&#10;                {&#10;                    EndGame();&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Public Interface&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus moves (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public void AddMoves(int moves)&#10;        {&#10;            movesRemaining += moves;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus score (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public new void AddScore(int score)&#10;        {&#10;            base.AddScore(score);&#10;            Events.Events.Publish(new ScoreUpdatedEvent(currentScore, score));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if the game can continue&#10;        /// &lt;/summary&gt;&#10;        public bool CanContinue()&#10;        {&#10;            return movesRemaining &gt; 0 &amp;&amp; matchFinder.HasPossibleMoves();&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Represents the current state of the Match-3 game&#10;    /// &lt;/summary&gt;&#10;    public enum GameState&#10;    {&#10;        NotInitialized,&#10;        Ready,&#10;        Playing,&#10;        Paused,&#10;        Ended&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using System.Collections;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System;&#13;&#10;using MiniGameFramework.Core;&#13;&#10;using MiniGameFramework.Events;&#13;&#10;&#13;&#10;namespace MiniGameFramework.Match3&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#13;&#10;    /// Extends MiniGameBase for framework integration&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public class Match3Game : MiniGameBase&#13;&#10;    {&#13;&#10;        [Header(&quot;Game Configuration&quot;)]&#13;&#10;        [SerializeField] private int targetScore = 1000;&#13;&#10;        [SerializeField] private int movesLimit = 30;&#13;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;System References&quot;)]&#13;&#10;        [SerializeField] private GridManager gridManager;&#13;&#10;        [SerializeField] private InputHandler inputHandler;&#13;&#10;        [SerializeField] private SwapHandler swapHandler;&#13;&#10;        [SerializeField] private MatchFinder matchFinder;&#13;&#10;        [SerializeField] private RefillSystem refillSystem;&#13;&#10;        &#13;&#10;        // Game state&#13;&#10;        private int _currentScore;&#13;&#10;        private int movesRemaining;&#13;&#10;        private int cascadeLevel;&#13;&#10;        private bool isProcessingMatches;&#13;&#10;        private GameState gameState;&#13;&#10;        &#13;&#10;        // Additional events specific to Match-3&#13;&#10;        public event Action&lt;int&gt; OnMovesChanged;&#13;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#13;&#10;        public event Action OnCascadeStarted;&#13;&#10;        public event Action OnCascadeEnded;&#13;&#10;        &#13;&#10;        // IMiniGame Implementation&#13;&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#13;&#10;        public bool IsInitialized { get; private set; }&#13;&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#13;&#10;&#13;&#10;        // Events&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#13;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#13;&#10;&#13;&#10;        // Properties&#13;&#10;        public int CurrentScore =&gt; _currentScore;&#13;&#10;        public int MovesRemaining =&gt; movesRemaining;&#13;&#10;        public int TargetScore =&gt; targetScore;&#13;&#10;        public GameState State =&gt; gameState;&#13;&#10;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public enum GameState&#13;&#10;    {&#13;&#10;        Initializing,&#13;&#10;        Ready,&#13;&#10;        Playing,&#13;&#10;        Paused,&#13;&#10;        GameOver&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/RunnerCube/Core/PlayerInteractionController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/RunnerCube/Core/PlayerInteractionController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace MiniGames.RunnerCube.Core&#10;{&#10;    public class PlayerInteractionController : MonoBehaviour&#10;    {&#10;        &#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using MiniGames.RunnerCube.Data;&#10;using Core.Events.RunnerCube;&#10;using Core.Managers;&#10;&#10;namespace MiniGames.RunnerCube.Core&#10;{&#10;    public class PlayerInteractionController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Detection Settings&quot;)]&#10;        [SerializeField] private Transform targetObject;&#10;        [SerializeField] private Vector3 boxCastSize = new Vector3(1f, 1f, 1f);&#10;        [SerializeField] private float detectionDistance = 2f;&#10;        [SerializeField] private LayerMask interactableLayerMask = -1;&#10;        &#10;        [Header(&quot;Debug&quot;)]&#10;        [SerializeField] private bool showGizmos = true;&#10;        &#10;        private void FixedUpdate()&#10;        {&#10;            if (targetObject == null) return;&#10;            &#10;            DetectInteractables();&#10;        }&#10;        &#10;        private void DetectInteractables()&#10;        {&#10;            // Cast a box in front of the target object&#10;            Vector3 origin = targetObject.position;&#10;            Vector3 direction = targetObject.forward;&#10;            &#10;            // Perform box cast&#10;            if (Physics.BoxCast(origin, boxCastSize * 0.5f, direction, out RaycastHit hit, &#10;                targetObject.rotation, detectionDistance, interactableLayerMask))&#10;            {&#10;                // Check if hit object has InteractableObjectController&#10;                InteractableObjectController interactable = hit.collider.GetComponent&lt;InteractableObjectController&gt;();&#10;                &#10;                if (interactable != null &amp;&amp; interactable.Data != null)&#10;                {&#10;                    HandleInteraction(interactable);&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void HandleInteraction(InteractableObjectController interactable)&#10;        {&#10;            // Check the type and publish appropriate event&#10;            switch (interactable.Data.InteractableType)&#10;            {&#10;                case InteractableTypeEnum.Obstacle:&#10;                    ManagerContainer.EventManager.Publish(new ObstacleTriggeredEvent &#10;                    { &#10;                        ObstacleObject = interactable &#10;                    });&#10;                    break;&#10;                    &#10;                case InteractableTypeEnum.Collectible:&#10;                    ManagerContainer.EventManager.Publish(new CollectibleTriggeredEvent &#10;                    { &#10;                        CollectibleObject = interactable &#10;                    });&#10;                    break;&#10;                    &#10;                case InteractableTypeEnum.FinishLine:&#10;                    ManagerContainer.EventManager.Publish(new FinishLineTriggeredEvent &#10;                    { &#10;                        FinishLineObject = interactable &#10;                    });&#10;                    break;&#10;                    &#10;                case InteractableTypeEnum.None:&#10;                default:&#10;                    // Do nothing for None type or unknown types&#10;                    break;&#10;            }&#10;        }&#10;        &#10;        private void OnDrawGizmos()&#10;        {&#10;            if (!showGizmos || targetObject == null) return;&#10;            &#10;            // Draw the box cast area&#10;            Gizmos.color = Color.yellow;&#10;            Vector3 origin = targetObject.position;&#10;            Vector3 direction = targetObject.forward;&#10;            Vector3 endPosition = origin + direction * detectionDistance;&#10;            &#10;            // Draw the box at origin&#10;            Gizmos.matrix = Matrix4x4.TRS(origin, targetObject.rotation, Vector3.one);&#10;            Gizmos.DrawWireCube(Vector3.zero, boxCastSize);&#10;            &#10;            // Draw the box at end position&#10;            Gizmos.matrix = Matrix4x4.TRS(endPosition, targetObject.rotation, Vector3.one);&#10;            Gizmos.DrawWireCube(Vector3.zero, boxCastSize);&#10;            &#10;            // Draw the cast direction&#10;            Gizmos.matrix = Matrix4x4.identity;&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawLine(origin, endPosition);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/RunnerCube/Core/RunnerInputController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/RunnerCube/Core/RunnerInputController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Core.Events.Level;&#10;using Core.Managers;&#10;&#10;namespace MiniGames.RunnerCube.Core&#10;{&#10;    public class RunnerInputController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private Vector2 horizontalLimits = new Vector2(-5f, 5f); // Sol ve sağ sınırlar&#10;        [SerializeField] private float movementSensitivity = 1f;&#10;        &#10;        [Header(&quot;Target GameObject&quot;)]&#10;        [SerializeField] private Transform targetObject;&#10;        &#10;        private bool canMove = false;&#10;        private Vector2 lastTouchPosition;&#10;        private bool isTouching = false;&#10;        &#10;        private void Start()&#10;        {&#10;            ManagerContainer.EventManager.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            ManagerContainer.EventManager.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;        }&#10;        &#10;        private void OnLevelStarted(LevelStartedEvent e)&#10;        {&#10;            canMove = true;&#10;        }&#10;        &#10;        private void LateUpdate()&#10;        {&#10;            if (!canMove || targetObject == null) return;&#10;            &#10;            HandleTouchInput();&#10;        }&#10;        &#10;        private void HandleTouchInput()&#10;        {&#10;            // Mouse/Touch input handling&#10;            if (Input.GetMouseButtonDown(0))&#10;            {&#10;                isTouching = true;&#10;                lastTouchPosition = Input.mousePosition;&#10;            }&#10;            else if (Input.GetMouseButtonUp(0))&#10;            {&#10;                isTouching = false;&#10;            }&#10;            else if (Input.GetMouseButton(0) &amp;&amp; isTouching)&#10;            {&#10;                Vector2 currentTouchPosition = Input.mousePosition;&#10;                Vector2 deltaPosition = currentTouchPosition - lastTouchPosition;&#10;                &#10;                // X ekseninde hareket&#10;                float horizontalMovement = deltaPosition.x * movementSensitivity * Time.deltaTime;&#10;                &#10;                // Mevcut pozisyonu al ve yeni pozisyonu hesapla&#10;                Vector3 currentPosition = targetObject.position;&#10;                float newXPosition = currentPosition.x + horizontalMovement;&#10;                &#10;                // Sınırları kontrol et&#10;                newXPosition = Mathf.Clamp(newXPosition, horizontalLimits.x, horizontalLimits.y);&#10;                &#10;                // Yeni pozisyonu uygula&#10;                targetObject.position = new Vector3(newXPosition, currentPosition.y, currentPosition.z);&#10;                &#10;                lastTouchPosition = currentTouchPosition;&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Core.Events.Level;&#10;using Core.Managers;&#10;&#10;namespace MiniGames.RunnerCube.Core&#10;{&#10;    public class RunnerInputController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private Vector2 horizontalLimits = new Vector2(-5f, 5f); // Left and right boundaries&#10;        [SerializeField] private float movementSensitivity = 1f;&#10;        &#10;        [Header(&quot;Target GameObject&quot;)]&#10;        [SerializeField] private Transform targetObject;&#10;        &#10;        private bool canMove;&#10;        private Vector2 lastTouchPosition;&#10;        private bool isTouching;&#10;        &#10;        private void Start()&#10;        {&#10;            ManagerContainer.EventManager.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            ManagerContainer.EventManager.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;        }&#10;        &#10;        private void OnLevelStarted(LevelStartedEvent e)&#10;        {&#10;            canMove = true;&#10;        }&#10;        &#10;        private void LateUpdate()&#10;        {&#10;            if (!canMove || targetObject == null) return;&#10;            &#10;            HandleTouchInput();&#10;        }&#10;        &#10;        private void HandleTouchInput()&#10;        {&#10;            // Mouse/Touch input handling&#10;            if (Input.GetMouseButtonDown(0))&#10;            {&#10;                isTouching = true;&#10;                lastTouchPosition = Input.mousePosition;&#10;            }&#10;            else if (Input.GetMouseButtonUp(0))&#10;            {&#10;                isTouching = false;&#10;            }&#10;            else if (Input.GetMouseButton(0) &amp;&amp; isTouching)&#10;            {&#10;                Vector2 currentTouchPosition = Input.mousePosition;&#10;                Vector2 deltaPosition = currentTouchPosition - lastTouchPosition;&#10;                &#10;                // Movement on X axis&#10;                float horizontalMovement = deltaPosition.x * movementSensitivity * Time.deltaTime;&#10;                &#10;                // Get current position and calculate new position&#10;                Vector3 currentPosition = targetObject.position;&#10;                float newXPosition = currentPosition.x + horizontalMovement;&#10;                &#10;                // Check boundaries&#10;                newXPosition = Mathf.Clamp(newXPosition, horizontalLimits.x, horizontalLimits.y);&#10;                &#10;                // Apply new position&#10;                targetObject.position = new Vector3(newXPosition, currentPosition.y, currentPosition.z);&#10;                &#10;                lastTouchPosition = currentTouchPosition;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/RunnerCube/Core/RunnerPlayerController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/RunnerCube/Core/RunnerPlayerController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace MiniGames.RunnerCube.Core&#10;{&#10;    public class RunnerPlayerController : MonoBehaviour&#10;    {&#10;        &#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Core.Events.Level;&#10;using Core.Events.RunnerCube;&#10;using Core.Managers;&#10;using System.Collections;&#10;&#10;namespace MiniGames.RunnerCube.Core&#10;{&#10;    public class RunnerPlayerController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private Transform playerObject;&#10;        [SerializeField] private float forwardSpeed = 5f;&#10;        [SerializeField] private float slowDownDuration = 2f;&#10;        &#10;        [Header(&quot;Scale Animation Settings&quot;)]&#10;        [SerializeField] private float scaleUpAmount = 0.3f;&#10;        [SerializeField] private float scaleDownAmount = 0.2f;&#10;        [SerializeField] private float scaleAnimationDuration = 0.5f;&#10;        &#10;        [Header(&quot;Game Rules&quot;)]&#10;        [SerializeField] private float minimumScale = 1f;&#10;        &#10;        private bool isMoving;&#10;        private Vector3 originalScale;&#10;        private Coroutine currentScaleCoroutine;&#10;        private Coroutine slowDownCoroutine;&#10;        &#10;        private void Start()&#10;        {&#10;            // Subscribe to events&#10;            ManagerContainer.EventManager.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            ManagerContainer.EventManager.Subscribe&lt;ObstacleTriggeredEvent&gt;(OnObstacleTriggered);&#10;            ManagerContainer.EventManager.Subscribe&lt;CollectibleTriggeredEvent&gt;(OnCollectibleTriggered);&#10;            ManagerContainer.EventManager.Subscribe&lt;FinishLineTriggeredEvent&gt;(OnFinishLineTriggered);&#10;            &#10;            // Store original scale&#10;            if (playerObject != null)&#10;            {&#10;                originalScale = playerObject.localScale;&#10;            }&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            // Unsubscribe from events&#10;            ManagerContainer.EventManager.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            ManagerContainer.EventManager.Unsubscribe&lt;ObstacleTriggeredEvent&gt;(OnObstacleTriggered);&#10;            ManagerContainer.EventManager.Unsubscribe&lt;CollectibleTriggeredEvent&gt;(OnCollectibleTriggered);&#10;            ManagerContainer.EventManager.Unsubscribe&lt;FinishLineTriggeredEvent&gt;(OnFinishLineTriggered);&#10;            &#10;            // Stop coroutines&#10;            if (currentScaleCoroutine != null)&#10;                StopCoroutine(currentScaleCoroutine);&#10;            if (slowDownCoroutine != null)&#10;                StopCoroutine(slowDownCoroutine);&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (isMoving &amp;&amp; playerObject != null)&#10;            {&#10;                // Move forward continuously&#10;                playerObject.Translate(Vector3.forward * (forwardSpeed * Time.deltaTime));&#10;                &#10;                // Check if scale dropped below minimum&#10;                CheckScaleFailure();&#10;            }&#10;        }&#10;        &#10;        private void OnLevelStarted(LevelStartedEvent e)&#10;        {&#10;            isMoving = true;&#10;        }&#10;        &#10;        private void OnObstacleTriggered(ObstacleTriggeredEvent e)&#10;        {&#10;            if (playerObject == null) return;&#10;            &#10;            // Scale down the player&#10;            Vector3 newScale = playerObject.localScale;&#10;            newScale.y -= scaleDownAmount;&#10;            &#10;            AnimateScale(newScale);&#10;        }&#10;        &#10;        private void OnCollectibleTriggered(CollectibleTriggeredEvent e)&#10;        {&#10;            if (playerObject == null) return;&#10;            &#10;            // Scale up the player&#10;            Vector3 newScale = playerObject.localScale;&#10;            newScale.y += scaleUpAmount;&#10;            &#10;            AnimateScale(newScale);&#10;            &#10;            // Destroy the collectible object&#10;            if (e.CollectibleObject != null)&#10;            {&#10;                Destroy(e.CollectibleObject.gameObject);&#10;            }&#10;        }&#10;        &#10;        private void OnFinishLineTriggered(FinishLineTriggeredEvent e)&#10;        {&#10;            // Gradually slow down and stop&#10;            SlowDownAndStop();&#10;            &#10;            // Publish level ended event&#10;            ManagerContainer.EventManager.Publish(new LevelEndedEvent());&#10;        }&#10;        &#10;        private void AnimateScale(Vector3 targetScale)&#10;        {&#10;            if (playerObject == null) return;&#10;            &#10;            // Stop current scale animation if running&#10;            if (currentScaleCoroutine != null)&#10;                StopCoroutine(currentScaleCoroutine);&#10;            &#10;            // Start new scale animation&#10;            currentScaleCoroutine = StartCoroutine(ScaleAnimation(targetScale));&#10;        }&#10;        &#10;        private IEnumerator ScaleAnimation(Vector3 targetScale)&#10;        {&#10;            Vector3 startScale = playerObject.localScale;&#10;            float elapsedTime = 0f;&#10;            &#10;            while (elapsedTime &lt; scaleAnimationDuration)&#10;            {&#10;                elapsedTime += Time.deltaTime;&#10;                float progress = elapsedTime / scaleAnimationDuration;&#10;                &#10;                // Apply easing (OutBounce effect simulation)&#10;                float easedProgress = EaseOutBounce(progress);&#10;                &#10;                playerObject.localScale = Vector3.Lerp(startScale, targetScale, easedProgress);&#10;                yield return null;&#10;            }&#10;            &#10;            playerObject.localScale = targetScale;&#10;            currentScaleCoroutine = null;&#10;        }&#10;        &#10;        private void SlowDownAndStop()&#10;        {&#10;            if (!isMoving) return;&#10;            &#10;            // Stop current slow down if running&#10;            if (slowDownCoroutine != null)&#10;                StopCoroutine(slowDownCoroutine);&#10;                &#10;            // Start slow down animation&#10;            slowDownCoroutine = StartCoroutine(SlowDownAnimation());&#10;        }&#10;        &#10;        private IEnumerator SlowDownAnimation()&#10;        {&#10;            float startSpeed = forwardSpeed;&#10;            float elapsedTime = 0f;&#10;            &#10;            while (elapsedTime &lt; slowDownDuration)&#10;            {&#10;                elapsedTime += Time.deltaTime;&#10;                float progress = elapsedTime / slowDownDuration;&#10;                &#10;                // Apply easing (OutQuart effect)&#10;                float easedProgress = EaseOutQuart(progress);&#10;                &#10;                forwardSpeed = Mathf.Lerp(startSpeed, 0f, easedProgress);&#10;                yield return null;&#10;            }&#10;            &#10;            forwardSpeed = 0f;&#10;            isMoving = false;&#10;            slowDownCoroutine = null;&#10;            &#10;            // Reset speed for next level&#10;            forwardSpeed = startSpeed;&#10;        }&#10;        &#10;        private void CheckScaleFailure()&#10;        {&#10;            if (playerObject != null &amp;&amp; playerObject.localScale.y &lt; minimumScale)&#10;            {&#10;                // Stop movement&#10;                isMoving = false;&#10;                &#10;                // Stop all animations&#10;                if (currentScaleCoroutine != null)&#10;                    StopCoroutine(currentScaleCoroutine);&#10;                if (slowDownCoroutine != null)&#10;                    StopCoroutine(slowDownCoroutine);&#10;                &#10;                // Publish level failed event&#10;                ManagerContainer.EventManager.Publish(new LevelFailedEvent());&#10;            }&#10;        }&#10;        &#10;        // Custom easing functions&#10;        private float EaseOutBounce(float t)&#10;        {&#10;            if (t &lt; 1f / 2.75f)&#10;            {&#10;                return 7.5625f * t * t;&#10;            }&#10;            else if (t &lt; 2f / 2.75f)&#10;            {&#10;                return 7.5625f * (t -= 1.5f / 2.75f) * t + 0.75f;&#10;            }&#10;            else if (t &lt; 2.5f / 2.75f)&#10;            {&#10;                return 7.5625f * (t -= 2.25f / 2.75f) * t + 0.9375f;&#10;            }&#10;            else&#10;            {&#10;                return 7.5625f * (t -= 2.625f / 2.75f) * t + 0.984375f;&#10;            }&#10;        }&#10;        &#10;        private float EaseOutQuart(float t)&#10;        {&#10;            return 1f - Mathf.Pow(1f - t, 4f);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>