<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/ILevel.cs" />
              <option name="updatedContent" value="namespace Core&#10;{&#10;    public interface ILevel&#10;    {&#10;        void Load();&#10;        void Unload();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Level.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core&#10;{&#10;    public class Level : MonoBehaviour, ILevel&#10;    {&#10;        [SerializeField] private string levelName;&#10;        [SerializeField] private bool isLoaded;&#10;        &#10;        public string LevelName =&gt; levelName;&#10;        public bool IsLoaded =&gt; isLoaded;&#10;        &#10;        public virtual void Load()&#10;        {&#10;            if (!isLoaded)&#10;            {&#10;                OnLevelLoad();&#10;                isLoaded = true;&#10;                Debug.Log($&quot;Level {levelName} loaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        public virtual void Unload()&#10;        {&#10;            if (isLoaded)&#10;            {&#10;                OnLevelUnload();&#10;                isLoaded = false;&#10;                Debug.Log($&quot;Level {levelName} unloaded.&quot;);&#10;            }&#10;        }&#10;        &#10;        // Override edilebilir metodlar&#10;        protected virtual void OnLevelLoad()&#10;        {&#10;            // Level yüklenirken yapılacak işlemler&#10;        }&#10;        &#10;        protected virtual void OnLevelUnload()&#10;        {&#10;            // Level boşaltılırken yapılacak işlemler&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            if (string.IsNullOrEmpty(levelName))&#10;            {&#10;                levelName = gameObject.name;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Cell.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/GridController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/GridController.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;using System.Collections.Generic;&#10;using MiniGames.Match3.Data;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    [RequireComponent(typeof(Match3LevelController))]&#10;    public class GridController : MonoBehaviour&#10;    {&#10;        public Match3LevelController levelController;&#10;        public CellController CellPrefab;&#10;&#10;        public CellController[,] Cells;&#10;&#10;        [SerializeField] private float padding = 1.2f;&#10;&#10;        [Header(&quot;Piece Generation&quot;)] [SerializeField]&#10;        private List&lt;PieceSO&gt; availablePieces = new List&lt;PieceSO&gt;();&#10;&#10;        public List&lt;PieceSO&gt; AvailablePieces =&gt; availablePieces;&#10;        [SerializeField] private float pieceGenerationDelay = 0.1f; // Her piece oluşturma arasındaki bekleme&#10;&#10;        [SerializeField]&#10;        private int maxGenerationAttempts = 10; // Eşleşme olmayan piece bulmak için maksimum deneme sayısı&#10;&#10;        [SerializeField] private bool preventAutoMatches = true; // Otomatik eşleşmeleri engelle&#10;&#10;        [Header(&quot;Match Controller&quot;)] [SerializeField]&#10;        private MatchController matchController;&#10;&#10;        private void Awake()&#10;        {&#10;            if (matchController == null)&#10;                matchController = GetComponent&lt;MatchController&gt;();&#10;        }&#10;&#10;        [ContextMenu(&quot;Generate Grid&quot;)]&#10;        public void CreateGrid()&#10;        {&#10;            if (levelController == null || levelController.Match3Data == null ||&#10;                levelController.Match3Data.GridData == null)&#10;            {&#10;                Debug.LogError(&quot;Match3Data or GridData is not set.&quot;);&#10;                return;&#10;            }&#10;&#10;            var gridData = levelController.Match3Data.GridData;&#10;            int gridSize = (int)gridData.GridSize;&#10;&#10;            // Cells array'ini initialize et&#10;            Cells = new CellController[gridSize, gridSize];&#10;&#10;            // Mevcut grid'i temizle (Editor güvenli)&#10;            ClearExistingGrid();&#10;&#10;            // GridData'dan cells'i initialize et&#10;            if (gridData.Cells == null)&#10;            {&#10;                Debug.LogError(&quot;GridData.Cells is not initialized.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Yeni grid oluştur&#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                for (int col = 0; col &lt; gridSize; col++)&#10;                {&#10;                    // World position: col = x, row = y (ama row'u ters çevir çünkü Unity'de Y yukarı doğru pozitif)&#10;                    Vector3 position = new Vector3(col * padding, -row * padding, 0);&#10;                    var cellObj = Instantiate(CellPrefab.gameObject, position, Quaternion.identity, transform);&#10;                    cellObj.name = $&quot;Cell_{row}_{col}&quot;;&#10;&#10;                    CellController cellController = cellObj.GetComponent&lt;CellController&gt;();&#10;                    // Grid position: x = col, y = row (0,0 = sol üst, 4,4 = sağ alt)&#10;                    cellController.GridPosition = new Vector2Int(col, row);&#10;&#10;                    // GridData'dan CellData'yı al ve set et&#10;                    var cellData = gridData.Cells[row, col];&#10;                    cellController.SetData(cellData);&#10;&#10;                    // Cells array'ine kaydet: [row, col] = [y, x]&#10;                    Cells[row, col] = cellController;&#10;                }&#10;            }&#10;        }&#10;&#10;        public void ClearExistingGrid()&#10;        {&#10;            for (int i = transform.childCount - 1; i &gt;= 0; i--)&#10;            {&#10;                Transform child = transform.GetChild(i);&#10;#if UNITY_EDITOR&#10;                if (Application.isPlaying)&#10;                    Destroy(child.gameObject);&#10;                else&#10;                    DestroyImmediate(child.gameObject);&#10;#else&#10;        Destroy(child.gameObject);&#10;#endif&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Swap işlemini dener. Tüm kuralları kontrol eder.&#10;        /// &lt;/summary&gt;&#10;        public bool TrySwap(CellController fromCell, Vector2Int direction)&#10;        {&#10;            if (fromCell == null) return false;&#10;&#10;            // Hedef pozisyonu hesapla&#10;            Vector2Int fromPos = fromCell.GridPosition;&#10;            Vector2Int toPos = fromPos + direction;&#10;&#10;            // Grid sınırları içinde mi kontrol et&#10;            if (!IsValidPosition(toPos))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Target position {toPos} is out of bounds&quot;);&#10;                return false;&#10;            }&#10;&#10;            CellController toCell = Cells[toPos.y, toPos.x];&#10;&#10;            // Swap kurallarını kontrol et&#10;            if (!CanSwapCells(fromCell, toCell))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Cannot swap {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Geçici swap yap ve match kontrol et&#10;            SwapCellData(fromCell, toCell);&#10;&#10;            bool hasMatches = CheckForMatches(fromPos) || CheckForMatches(toPos);&#10;&#10;            if (hasMatches)&#10;            {&#10;                Debug.Log($&quot;Swap successful: {fromPos} &lt;-&gt; {toPos}&quot;);&#10;&#10;                // Animasyonlu swap gerçekleştir&#10;                PerformAnimatedSwap(fromCell, toCell);&#10;&#10;                // Sadece swap yapılan cell'lerden etkilenen eşleşmeleri bul ve animasyon tetikle&#10;                TriggerMatchAnimationsForSwappedCells(fromCell, toCell);&#10;&#10;                return true;&#10;            }&#10;            else&#10;            {&#10;                // Match bulunamadı, swap'i geri al&#10;                SwapCellData(fromCell, toCell);&#10;&#10;                // Swap yapılmaya çalışılan cell'lerde WrongMatch animasyonu tetikle&#10;                fromCell.TriggerWrongMatchAnimation();&#10;                toCell.TriggerWrongMatchAnimation();&#10;&#10;                Debug.Log($&quot;Swap failed: No matches found after swapping {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Sadece swap yapılan cell'lerden etkilenen eşleşmeleri bulır ve match işlemlerini başlatır&#10;        /// &lt;/summary&gt;&#10;        private void TriggerMatchAnimationsForSwappedCells(CellController cell1, CellController cell2)&#10;        {&#10;            if (matchController != null)&#10;            {&#10;                matchController.ProcessSwapMatches(cell1, cell2);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;MatchController is not assigned!&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda 3'lü match var mı kontrol eder (MatchController'dan delege edilir)&#10;        /// &lt;/summary&gt;&#10;        private bool CheckForMatches(Vector2Int position)&#10;        {&#10;            if (matchController != null)&#10;            {&#10;                return matchController.CheckForMatches(position);&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki cell arasında animasyonlı swap gerçekleştirir&#10;        /// &lt;/summary&gt;&#10;        private void PerformAnimatedSwap(CellController cell1, CellController cell2)&#10;        {&#10;            Vector3 cell1Position = cell1.transform.position;&#10;            Vector3 cell2Position = cell2.transform.position;&#10;&#10;            // Her iki cell'i de karşı pozisyona animasyonla götür&#10;            cell1.MoveTo(cell2Position);&#10;            cell2.MoveTo(cell1Position);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki cell'in swap edilip edilemeyeceğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool CanSwapCells(CellController fromCell, CellController toCell)&#10;        {&#10;            // Null kontrolleri&#10;            if (fromCell == null || toCell == null) return false;&#10;&#10;            // Wall kontrolü - Duvar ile hiçbir şey swap edilemez&#10;            if (fromCell.IsWall() || toCell.IsWall())&#10;            {&#10;                return false;&#10;            }&#10;&#10;            // En az bir cell'de piece olmalı&#10;            if (fromCell.IsEmpty() &amp;&amp; toCell.IsEmpty())&#10;            {&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki cell'in data'larını swap eder&#10;        /// &lt;/summary&gt;&#10;        private void SwapCellData(CellController cell1, CellController cell2)&#10;        {&#10;            var cell1Position = cell1.GridPosition;&#10;            var cell2Position = cell2.GridPosition;&#10;&#10;            // Grid'deki cell'lerin pozisyonlarını güncelle&#10;            Cells[cell1Position.y, cell1Position.x] = cell2;&#10;            Cells[cell2Position.y, cell2Position.x] = cell1;&#10;            // Cell'lerin grid pozisyonlarını güncelle&#10;            cell1.GridPosition = cell2Position;&#10;            cell2.GridPosition = cell1Position;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki rengin eşleşip eşleşmediğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool ColorsMatch(PieceColorEnum color1, PieceColorEnum color2)&#10;        {&#10;            return color1 == color2;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Pozisyonun grid sınırları içinde olup olmadığını kontrol eder&#10;        /// &lt;/summary&gt;&#10;        public bool IsValidPosition(Vector2Int position)&#10;        {&#10;            if (Cells == null) return false;&#10;&#10;            int gridSize = Cells.GetLength(0);&#10;            return position.x &gt;= 0 &amp;&amp; position.x &lt; gridSize &amp;&amp;&#10;                   position.y &gt;= 0 &amp;&amp; position.y &lt; gridSize;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Boş alanları availablePieces listesinden seçilen piece'lerle doldurur&#10;        /// &lt;/summary&gt;&#10;        public IEnumerator CreateNewPieces()&#10;        {&#10;            if (Cells == null || availablePieces == null || availablePieces.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;Cannot create new pieces: availablePieces list is empty or null&quot;);&#10;                yield break;&#10;            }&#10;&#10;            int gridSize = Cells.GetLength(0);&#10;            bool hasNewPieces = false;&#10;            var createdPieces = new List&lt;Vector2Int&gt;();&#10;            // Her sütunu aşağıdan yukarıya doğru kontrol et&#10;            for (int col = 0; col &lt; gridSize; col++)&#10;            {&#10;                for (int row = gridSize - 1; row &gt;= 0; row--)&#10;                {&#10;                    Vector2Int pos = new Vector2Int(col, row);&#10;                    CellController cell = Cells[pos.y, pos.x];&#10;&#10;                    // Boş cell ve duvar değilse yeni piece oluştur&#10;                    if (cell.IsEmpty() &amp;&amp; !cell.IsWall())&#10;                    {&#10;                        CreateNewPieceAt(pos);&#10;                        createdPieces.Add(pos);&#10;                        hasNewPieces = true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (hasNewPieces)&#10;            {&#10;                Debug.Log(&quot;New pieces created to fill empty spaces&quot;);&#10;                // Yeni piece'lerin yerleşmesi için kısa bekleme&#10;                yield return new WaitForSeconds(0.2f);&#10;&#10;                // Cascade eşleşmeleri kontrol et&#10;                //yield return StartCoroutine(CheckForCascadingMatches());&#10;                yield return StartCoroutine(CheckForCascadingMatches(createdPieces));&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda availablePieces listesinden rastgele bir piece oluşturur&#10;        /// Eşleşme kontrolü yaparak otomatik match'leri engeller&#10;        /// &lt;/summary&gt;&#10;        private void CreateNewPieceAt(Vector2Int position)&#10;        {&#10;            if (!IsValidPosition(position)) return;&#10;&#10;            CellController cell = Cells[position.y, position.x];&#10;            if (cell.IsWall()) return;&#10;&#10;            if (availablePieces == null || availablePieces.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;availablePieces list is empty. Cannot create new piece.&quot;);&#10;                return;&#10;            }&#10;&#10;            PieceSO selectedPiece = null;&#10;&#10;            if (preventAutoMatches)&#10;            {&#10;                // Eşleşme yapmayacak piece bulmaya çalış&#10;                selectedPiece = FindNonMatchingPiece(position);&#10;            }&#10;&#10;            // Eğer eşleşmeyen piece bulunamadıysa veya preventAutoMatches false ise rastgele seç&#10;            if (selectedPiece == null)&#10;            {&#10;                selectedPiece = availablePieces[Random.Range(0, availablePieces.Count)];&#10;            }&#10;&#10;            // Piece'in kopyasını oluştur (ScriptableObject referansını korumak için)&#10;            var newPieceData = ScriptableObject.CreateInstance&lt;PieceSO&gt;();&#10;            newPieceData.pieceTypeEnum = selectedPiece.pieceTypeEnum;&#10;            newPieceData.Color = selectedPiece.Color;&#10;            newPieceData.Sprite = selectedPiece.Sprite;&#10;            newPieceData.pieceColor = selectedPiece.pieceColor;&#10;&#10;            var cellData = new CellData&#10;            {&#10;                Piece = newPieceData,&#10;            };&#10;            // Cell'e yeni piece'i set et&#10;            cell.SetData(cellData);&#10;&#10;            //Debug.Log($&quot;Created new {newPieceData.pieceTypeEnum} piece with color {newPieceData.Color} at {position}&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda eşleşme yapmayacak bir piece bulmaya çalışır&#10;        /// &lt;/summary&gt;&#10;        private PieceSO FindNonMatchingPiece(Vector2Int position)&#10;        {&#10;            // Mevcut cell'i geçici olarak kaydet&#10;            CellController targetCell = Cells[position.y, position.x];&#10;&#10;            for (int attempt = 0; attempt &lt; maxGenerationAttempts; attempt++)&#10;            {&#10;                // Rastgele bir piece seç&#10;                PieceSO candidatePiece = availablePieces[Random.Range(0, availablePieces.Count)];&#10;&#10;                // Geçici olarak bu piece'i yerleştir&#10;                var tempPieceData = ScriptableObject.CreateInstance&lt;PieceSO&gt;();&#10;                tempPieceData.pieceTypeEnum = candidatePiece.pieceTypeEnum;&#10;                tempPieceData.Color = candidatePiece.Color;&#10;                tempPieceData.Sprite = candidatePiece.Sprite;&#10;                tempPieceData.pieceColor = candidatePiece.pieceColor;&#10;&#10;                var tempCellData = new CellData&#10;                {&#10;                    Piece = tempPieceData,&#10;                };&#10;&#10;                targetCell.SetData(tempCellData,true);&#10;&#10;                // Bu piece ile eşleşme oluşur mu kontrol et&#10;                bool wouldCreateMatch = CheckForMatches(position);&#10;&#10;                // Eğer eşleşme oluşmazsa bu piece'i kabul et&#10;                if (!wouldCreateMatch)&#10;                {&#10;                    // Geçici piece'i temizle (gerçek piece CreateNewPieceAt'da oluşturulacak)&#10;                    targetCell.ClearPiece();&#10;                    return candidatePiece;&#10;                }&#10;&#10;                // Geçici piece'i temizle ve başka bir piece dene&#10;                targetCell.ClearPiece();&#10;            }&#10;&#10;            // Maksimum deneme sayısına ulaşıldı, null döndür (rastgele piece kullanılacak)&#10;            Debug.Log(&#10;                $&quot;Could not find non-matching piece for position {position} after {maxGenerationAttempts} attempts&quot;);&#10;            return null;&#10;        }&#10;        &#10;        &#10;&#10;        private IEnumerator CheckForCascadingMatches(List&lt;Vector2Int&gt; createdPieces)&#10;        {&#10;            yield return new WaitForSeconds(Time.deltaTime * createdPieces.Count * 10);&#10;            for (int i = 0; i &lt; createdPieces.Count; i++)&#10;            {&#10;                if (CheckForMatches(createdPieces[i]))&#10;                {&#10;                    matchController.ProcessMatchesAtCell(Cells[createdPieces[i].y, createdPieces[i].x]);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;using System.Collections.Generic;&#10;using MiniGames.Match3.Data;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    [RequireComponent(typeof(Match3LevelController))]&#10;    public class GridController : MonoBehaviour&#10;    {&#10;        public Match3LevelController levelController;&#10;        public CellController CellPrefab;&#10;&#10;        public CellController[,] Cells;&#10;&#10;        [SerializeField] private float padding = 1.2f;&#10;&#10;        [Header(&quot;Piece Generation&quot;)] [SerializeField]&#10;        private List&lt;PieceSO&gt; availablePieces = new List&lt;PieceSO&gt;();&#10;&#10;        public List&lt;PieceSO&gt; AvailablePieces =&gt; availablePieces;&#10;        [SerializeField] private float pieceGenerationDelay = 0.1f; // Her piece oluşturma arasındaki bekleme&#10;&#10;        [SerializeField]&#10;        private int maxGenerationAttempts = 10; // Eşleşme olmayan piece bulmak için maksimum deneme sayısı&#10;&#10;        [SerializeField] private bool preventAutoMatches = true; // Otomatik eşleşmeleri engelle&#10;&#10;        [Header(&quot;Match Controller&quot;)] [SerializeField]&#10;        private MatchController matchController;&#10;&#10;        [Header(&quot;Special Piece Chance&quot;)]&#10;        [SerializeField] private float specialPieceSpawnChance = 0.1f; // Özel piece'lerin oluşma olasılığı (0-1 arası)&#10;        [SerializeField] private bool limitSpecialPiecesOnInit = true; // Oyun başlangıcında özel piece'leri sınırlandır&#10;&#10;        private void Awake()&#10;        {&#10;            if (matchController == null)&#10;                matchController = GetComponent&lt;MatchController&gt;();&#10;        }&#10;&#10;        [ContextMenu(&quot;Generate Grid&quot;)]&#10;        public void CreateGrid()&#10;        {&#10;            if (levelController == null || levelController.Match3Data == null ||&#10;                levelController.Match3Data.GridData == null)&#10;            {&#10;                Debug.LogError(&quot;Match3Data or GridData is not set.&quot;);&#10;                return;&#10;            }&#10;&#10;            var gridData = levelController.Match3Data.GridData;&#10;            int gridSize = (int)gridData.GridSize;&#10;&#10;            // Cells array'ini initialize et&#10;            Cells = new CellController[gridSize, gridSize];&#10;&#10;            // Mevcut grid'i temizle (Editor güvenli)&#10;            ClearExistingGrid();&#10;&#10;            // GridData'dan cells'i initialize et&#10;            if (gridData.Cells == null)&#10;            {&#10;                Debug.LogError(&quot;GridData.Cells is not initialized.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Yeni grid oluştur&#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                for (int col = 0; col &lt; gridSize; col++)&#10;                {&#10;                    // World position: col = x, row = y (ama row'u ters çevir çünkü Unity'de Y yukarı doğru pozitif)&#10;                    Vector3 position = new Vector3(col * padding, -row * padding, 0);&#10;                    var cellObj = Instantiate(CellPrefab.gameObject, position, Quaternion.identity, transform);&#10;                    cellObj.name = $&quot;Cell_{row}_{col}&quot;;&#10;&#10;                    CellController cellController = cellObj.GetComponent&lt;CellController&gt;();&#10;                    // Grid position: x = col, y = row (0,0 = sol üst, 4,4 = sağ alt)&#10;                    cellController.GridPosition = new Vector2Int(col, row);&#10;&#10;                    // GridData'dan CellData'yı al ve set et&#10;                    var cellData = gridData.Cells[row, col];&#10;                    cellController.SetData(cellData);&#10;&#10;                    // Cells array'ine kaydet: [row, col] = [y, x]&#10;                    Cells[row, col] = cellController;&#10;                }&#10;            }&#10;        }&#10;&#10;        public void ClearExistingGrid()&#10;        {&#10;            for (int i = transform.childCount - 1; i &gt;= 0; i--)&#10;            {&#10;                Transform child = transform.GetChild(i);&#10;#if UNITY_EDITOR&#10;                if (Application.isPlaying)&#10;                    Destroy(child.gameObject);&#10;                else&#10;                    DestroyImmediate(child.gameObject);&#10;#else&#10;        Destroy(child.gameObject);&#10;#endif&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Swap işlemini dener. Tüm kuralları kontrol eder.&#10;        /// &lt;/summary&gt;&#10;        public bool TrySwap(CellController fromCell, Vector2Int direction)&#10;        {&#10;            if (fromCell == null) return false;&#10;&#10;            // Hedef pozisyonu hesapla&#10;            Vector2Int fromPos = fromCell.GridPosition;&#10;            Vector2Int toPos = fromPos + direction;&#10;&#10;            // Grid sınırları içinde mi kontrol et&#10;            if (!IsValidPosition(toPos))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Target position {toPos} is out of bounds&quot;);&#10;                return false;&#10;            }&#10;&#10;            CellController toCell = Cells[toPos.y, toPos.x];&#10;&#10;            // Swap kurallarını kontrol et&#10;            if (!CanSwapCells(fromCell, toCell))&#10;            {&#10;                Debug.Log($&quot;Swap failed: Cannot swap {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Geçici swap yap ve match kontrol et&#10;            SwapCellData(fromCell, toCell);&#10;&#10;            bool hasMatches = CheckForMatches(fromPos) || CheckForMatches(toPos);&#10;&#10;            if (hasMatches)&#10;            {&#10;                Debug.Log($&quot;Swap successful: {fromPos} &lt;-&gt; {toPos}&quot;);&#10;&#10;                // Animasyonlu swap gerçekleştir&#10;                PerformAnimatedSwap(fromCell, toCell);&#10;&#10;                // Sadece swap yapılan cell'lerden etkilenen eşleşmeleri bul ve animasyon tetikle&#10;                TriggerMatchAnimationsForSwappedCells(fromCell, toCell);&#10;&#10;                return true;&#10;            }&#10;            else&#10;            {&#10;                // Match bulunamadı, swap'i geri al&#10;                SwapCellData(fromCell, toCell);&#10;&#10;                // Swap yapılmaya çalışılan cell'lerde WrongMatch animasyonu tetikle&#10;                fromCell.TriggerWrongMatchAnimation();&#10;                toCell.TriggerWrongMatchAnimation();&#10;&#10;                Debug.Log($&quot;Swap failed: No matches found after swapping {fromPos} with {toPos}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Sadece swap yapılan cell'lerden etkilenen eşleşmeleri bulır ve match işlemlerini başlatır&#10;        /// &lt;/summary&gt;&#10;        private void TriggerMatchAnimationsForSwappedCells(CellController cell1, CellController cell2)&#10;        {&#10;            if (matchController != null)&#10;            {&#10;                matchController.ProcessSwapMatches(cell1, cell2);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;MatchController is not assigned!&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda 3'lü match var mı kontrol eder (MatchController'dan delege edilir)&#10;        /// &lt;/summary&gt;&#10;        private bool CheckForMatches(Vector2Int position)&#10;        {&#10;            if (matchController != null)&#10;            {&#10;                return matchController.CheckForMatches(position);&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki cell arasında animasyonlı swap gerçekleştirir&#10;        /// &lt;/summary&gt;&#10;        private void PerformAnimatedSwap(CellController cell1, CellController cell2)&#10;        {&#10;            Vector3 cell1Position = cell1.transform.position;&#10;            Vector3 cell2Position = cell2.transform.position;&#10;&#10;            // Her iki cell'i de karşı pozisyona animasyonla götür&#10;            cell1.MoveTo(cell2Position);&#10;            cell2.MoveTo(cell1Position);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki cell'in swap edilip edilemeyeceğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool CanSwapCells(CellController fromCell, CellController toCell)&#10;        {&#10;            // Null kontrolleri&#10;            if (fromCell == null || toCell == null) return false;&#10;&#10;            // Wall kontrolü - Duvar ile hiçbir şey swap edilemez&#10;            if (fromCell.IsWall() || toCell.IsWall())&#10;            {&#10;                return false;&#10;            }&#10;&#10;            // En az bir cell'de piece olmalı&#10;            if (fromCell.IsEmpty() &amp;&amp; toCell.IsEmpty())&#10;            {&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki cell'in data'larını swap eder&#10;        /// &lt;/summary&gt;&#10;        private void SwapCellData(CellController cell1, CellController cell2)&#10;        {&#10;            var cell1Position = cell1.GridPosition;&#10;            var cell2Position = cell2.GridPosition;&#10;&#10;            // Grid'deki cell'lerin pozisyonlarını güncelle&#10;            Cells[cell1Position.y, cell1Position.x] = cell2;&#10;            Cells[cell2Position.y, cell2Position.x] = cell1;&#10;            // Cell'lerin grid pozisyonlarını güncelle&#10;            cell1.GridPosition = cell2Position;&#10;            cell2.GridPosition = cell1Position;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki rengin eşleşip eşleşmediğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool ColorsMatch(PieceColorEnum color1, PieceColorEnum color2)&#10;        {&#10;            return color1 == color2;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Pozisyonun grid sınırları içinde olup olmadığını kontrol eder&#10;        /// &lt;/summary&gt;&#10;        public bool IsValidPosition(Vector2Int position)&#10;        {&#10;            if (Cells == null) return false;&#10;&#10;            int gridSize = Cells.GetLength(0);&#10;            return position.x &gt;= 0 &amp;&amp; position.x &lt; gridSize &amp;&amp;&#10;                   position.y &gt;= 0 &amp;&amp; position.y &lt; gridSize;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Boş alanları availablePieces listesinden seçilen piece'lerle doldurur&#10;        /// &lt;/summary&gt;&#10;        public IEnumerator CreateNewPieces()&#10;        {&#10;            if (Cells == null || availablePieces == null || availablePieces.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;Cannot create new pieces: availablePieces list is empty or null&quot;);&#10;                yield break;&#10;            }&#10;&#10;            int gridSize = Cells.GetLength(0);&#10;            bool hasNewPieces = false;&#10;            var createdPieces = new List&lt;Vector2Int&gt;();&#10;            // Her sütunu aşağıdan yukarıya doğru kontrol et&#10;            for (int col = 0; col &lt; gridSize; col++)&#10;            {&#10;                for (int row = gridSize - 1; row &gt;= 0; row--)&#10;                {&#10;                    Vector2Int pos = new Vector2Int(col, row);&#10;                    CellController cell = Cells[pos.y, pos.x];&#10;&#10;                    // Boş cell ve duvar değilse yeni piece oluştur&#10;                    if (cell.IsEmpty() &amp;&amp; !cell.IsWall())&#10;                    {&#10;                        CreateNewPieceAt(pos);&#10;                        createdPieces.Add(pos);&#10;                        hasNewPieces = true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (hasNewPieces)&#10;            {&#10;                Debug.Log(&quot;New pieces created to fill empty spaces&quot;);&#10;                // Yeni piece'lerin yerleşmesi için kısa bekleme&#10;                yield return new WaitForSeconds(0.2f);&#10;&#10;                // Cascade eşleşmeleri kontrol et&#10;                //yield return StartCoroutine(CheckForCascadingMatches());&#10;                yield return StartCoroutine(CheckForCascadingMatches(createdPieces));&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda availablePieces listesinden rastgele bir piece oluşturur&#10;        /// Eşleşme kontrolü yaparak otomatik match'leri engeller&#10;        /// &lt;/summary&gt;&#10;        private void CreateNewPieceAt(Vector2Int position)&#10;        {&#10;            if (!IsValidPosition(position)) return;&#10;&#10;            CellController cell = Cells[position.y, position.x];&#10;            if (cell.IsWall()) return;&#10;&#10;            if (availablePieces == null || availablePieces.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;availablePieces list is empty. Cannot create new piece.&quot;);&#10;                return;&#10;            }&#10;&#10;            PieceSO selectedPiece = null;&#10;&#10;            if (preventAutoMatches)&#10;            {&#10;                // Eşleşme yapmayacak piece bulmaya çalış&#10;                selectedPiece = FindNonMatchingPiece(position);&#10;            }&#10;&#10;            // Eğer eşleşmeyen piece bulunamadıysa veya preventAutoMatches false ise rastgele seç&#10;            if (selectedPiece == null)&#10;            {&#10;                selectedPiece = availablePieces[Random.Range(0, availablePieces.Count)];&#10;            }&#10;&#10;            // Piece'in kopyasını oluştur (ScriptableObject referansını korumak için)&#10;            var newPieceData = ScriptableObject.CreateInstance&lt;PieceSO&gt;();&#10;            newPieceData.pieceTypeEnum = selectedPiece.pieceTypeEnum;&#10;            newPieceData.Color = selectedPiece.Color;&#10;            newPieceData.Sprite = selectedPiece.Sprite;&#10;            newPieceData.pieceColor = selectedPiece.pieceColor;&#10;&#10;            var cellData = new CellData&#10;            {&#10;                Piece = newPieceData,&#10;            };&#10;            // Cell'e yeni piece'i set et&#10;            cell.SetData(cellData);&#10;&#10;            //Debug.Log($&quot;Created new {newPieceData.pieceTypeEnum} piece with color {newPieceData.Color} at {position}&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda eşleşme yapmayacak bir piece bulmaya çalışır&#10;        /// &lt;/summary&gt;&#10;        private PieceSO FindNonMatchingPiece(Vector2Int position)&#10;        {&#10;            // Mevcut cell'i geçici olarak kaydet&#10;            CellController targetCell = Cells[position.y, position.x];&#10;&#10;            // Sadece normal piece'leri içeren bir liste oluştur (performans için)&#10;            List&lt;PieceSO&gt; normalPieces = new List&lt;PieceSO&gt;();&#10;            foreach (var piece in availablePieces)&#10;            {&#10;                if (piece.pieceTypeEnum == PieceTypeEnum.Normal)&#10;                {&#10;                    normalPieces.Add(piece);&#10;                }&#10;            }&#10;&#10;            // Normal piece yoksa, tüm listeyi kullan&#10;            if (normalPieces.Count == 0)&#10;            {&#10;                normalPieces = availablePieces;&#10;            }&#10;&#10;            for (int attempt = 0; attempt &lt; maxGenerationAttempts; attempt++)&#10;            {&#10;                PieceSO candidatePiece;&#10;&#10;                // Özel piece mi yoksa normal piece mı seçileceğini belirle&#10;                bool selectSpecialPiece = Random.value &lt; specialPieceSpawnChance &amp;&amp; !limitSpecialPiecesOnInit;&#10;&#10;                if (selectSpecialPiece)&#10;                {&#10;                    // Özel piece seçme şansı var&#10;                    candidatePiece = availablePieces[Random.Range(0, availablePieces.Count)];&#10;                }&#10;                else&#10;                {&#10;                    // Normal piece seç&#10;                    candidatePiece = normalPieces[Random.Range(0, normalPieces.Count)];&#10;                }&#10;&#10;                // Geçici olarak bu piece'i yerleştir&#10;                var tempPieceData = ScriptableObject.CreateInstance&lt;PieceSO&gt;();&#10;                tempPieceData.pieceTypeEnum = selectSpecialPiece ? candidatePiece.pieceTypeEnum : PieceTypeEnum.Normal;&#10;                tempPieceData.Color = candidatePiece.Color;&#10;                tempPieceData.Sprite = candidatePiece.Sprite;&#10;                tempPieceData.pieceColor = candidatePiece.pieceColor;&#10;&#10;                var tempCellData = new CellData&#10;                {&#10;                    Piece = tempPieceData,&#10;                };&#10;&#10;                targetCell.SetData(tempCellData, true);&#10;&#10;                // Bu piece ile eşleşme oluşur mu kontrol et&#10;                bool wouldCreateMatch = CheckForMatches(position);&#10;&#10;                // Eğer eşleşme oluşmazsa bu piece'i kabul et&#10;                if (!wouldCreateMatch)&#10;                {&#10;                    // Geçici piece'i temizle (gerçek piece CreateNewPieceAt'da oluşturulacak)&#10;                    targetCell.ClearPiece();&#10;                    return candidatePiece;&#10;                }&#10;&#10;                // Geçici piece'i temizle ve başka bir piece dene&#10;                targetCell.ClearPiece();&#10;            }&#10;&#10;            // Maksimum deneme sayısına ulaşıldı, normal piece seç&#10;            Debug.Log($&quot;Could not find non-matching piece for position {position} after {maxGenerationAttempts} attempts&quot;);&#10;&#10;            // Default olarak normal piece döndür&#10;            foreach (var piece in availablePieces)&#10;            {&#10;                if (piece.pieceTypeEnum == PieceTypeEnum.Normal)&#10;                {&#10;                    return piece;&#10;                }&#10;            }&#10;&#10;            return availablePieces[0]; // Hiç normal piece yoksa ilk piece'i döndür&#10;        }&#10;        &#10;        &#10;&#10;        private IEnumerator CheckForCascadingMatches(List&lt;Vector2Int&gt; createdPieces)&#10;        {&#10;            yield return new WaitForSeconds(Time.deltaTime * createdPieces.Count * 10);&#10;            for (int i = 0; i &lt; createdPieces.Count; i++)&#10;            {&#10;                if (CheckForMatches(createdPieces[i]))&#10;                {&#10;                    matchController.ProcessMatchesAtCell(Cells[createdPieces[i].y, createdPieces[i].x]);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/MatchController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Core/MatchController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using MiniGames.Match3.Data;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Match3 oyununda eşleşme işlemlerini yöneten sınıf&#10;    /// &lt;/summary&gt;&#10;    public class MatchController : MonoBehaviour&#10;    {&#10;        [Header(&quot;References&quot;)] [SerializeField]&#10;        private GridController gridController;&#10;&#10;        [Header(&quot;Match Settings&quot;)] [SerializeField]&#10;        private float matchProcessDelay = 1.0f;&#10;&#10;        [SerializeField] private float additionalDelay = 0.2f;&#10;        [SerializeField] private float destructionEffectDelay = 0.05f; // Her cell yok etme arasındaki efekt gecikmesi&#10;        [SerializeField] private float animationStartDelay = 0.1f; // Her animasyon başlatma arasındaki gecikme&#10;        [SerializeField] private float animationDuration = 0.5f; // Match animasyonunun süresi&#10;&#10;        [Header(&quot;Special Piece Generation&quot;)] [SerializeField]&#10;        private int minCellsForBomb = 7; // Bomba oluşturmak için minimum eşleşen cell sayısı&#10;&#10;        [SerializeField] private int minCellsForRow = 5; // Row piece oluşturmak için minimum cell sayısı&#10;        [SerializeField] private int minCellsForColumn = 5; // Column piece oluşturmak için minimum cell sayısı&#10;        [SerializeField] private float specialPieceChance = 0.1f; // Özel piece oluşturma şansı (0-1)&#10;&#10;        private void Awake()&#10;        {&#10;            if (gridController == null)&#10;                gridController = GetComponent&lt;GridController&gt;();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Swap yapılan cell'lerden etkilenen eşleşmeleri bulur ve işler&#10;        /// &lt;/summary&gt;&#10;        public void ProcessSwapMatches(CellController cell1, CellController cell2)&#10;        {&#10;            HashSet&lt;CellController&gt; allMatchedCells = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Cell1'den etkilenen eşleşmeleri bul&#10;            List&lt;CellController&gt; cell1Matches = GetMatchedCellsAtPosition(cell1.GridPosition);&#10;            foreach (var cell in cell1Matches)&#10;            {&#10;                allMatchedCells.Add(cell);&#10;            }&#10;&#10;            // Cell2'den etkilenen eşleşmeleri bul&#10;            List&lt;CellController&gt; cell2Matches = GetMatchedCellsAtPosition(cell2.GridPosition);&#10;            foreach (var cell in cell2Matches)&#10;            {&#10;                allMatchedCells.Add(cell);&#10;            }&#10;            &#10;            // Debug log ile eşleşen cell'lerin listesini yazdır&#10;            Debug.Log($&quot;=== SWAP MATCH RESULTS ===&quot;);&#10;            Debug.Log($&quot;Swapped cells: {cell1.GridPosition} &lt;-&gt; {cell2.GridPosition}&quot;);&#10;            Debug.Log($&quot;Cell1 matches: {cell1Matches.Count}&quot;);&#10;            Debug.Log($&quot;Cell2 matches: {cell2Matches.Count}&quot;);&#10;            Debug.Log($&quot;Total unique matches: {allMatchedCells.Count}&quot;);&#10;            &#10;            if (allMatchedCells.Count &gt; 0)&#10;            {&#10;                // Animasyonları gecikmeyle başlat ve ardından ProcessMatches'i çağır&#10;                StartCoroutine(TriggerMatchAnimationsAndProcess(new List&lt;CellController&gt;(allMatchedCells)));&#10;            }&#10;            &#10;            Debug.Log($&quot;Match processing started for {allMatchedCells.Count} cells affected by swap&quot;);&#10;        }&#10;&#10;        public void ProcessMatchesAtCell(CellController startCell)&#10;        {&#10;            HashSet&lt;CellController&gt; allMatchedCells = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Cell1'den etkilenen eşleşmeleri bul&#10;            List&lt;CellController&gt; cell1Matches = GetMatchedCellsAtPosition(startCell.GridPosition);&#10;            foreach (var cell in cell1Matches)&#10;            {&#10;                    allMatchedCells.Add(cell);&#10;            }&#10;            &#10;            // Debug log ile eşleşen cell'lerin listesini yazdır&#10;            Debug.Log($&quot;=== SWAP MATCH RESULTS ===&quot;);&#10;            Debug.Log($&quot;Total unique matches: {allMatchedCells.Count}&quot;);&#10;            &#10;            if (allMatchedCells.Count &gt; 0)&#10;            {&#10;                // Animasyonları gecikmeyle başlat ve ardından ProcessMatches'i çağır&#10;                StartCoroutine(TriggerMatchAnimationsAndProcess(new List&lt;CellController&gt;(allMatchedCells)));&#10;            }&#10;            &#10;            Debug.Log($&quot;Match processing started for {allMatchedCells.Count} cells affected by create&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda 3'lü match var mı kontrol eder&#10;        /// &lt;/summary&gt;&#10;        public bool CheckForMatches(Vector2Int position)&#10;        {&#10;            if (!gridController.IsValidPosition(position)) return false;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) return false;&#10;&#10;            PieceColorEnum targetColor = cell.CellData.Piece.pieceColor;&#10;&#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul (sarmal yapı)&#10;            HashSet&lt;Vector2Int&gt; connectedCells = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedCells);&#10;&#10;            // 3 veya daha fazla bağlı cell varsa match&#10;            return connectedCells.Count &gt;= 3;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyondaki tüm bağlı eşleşen cell'leri döndürür&#10;        /// &lt;/summary&gt;&#10;        private List&lt;CellController&gt; GetMatchedCellsAtPosition(Vector2Int position)&#10;        {&#10;            List&lt;CellController&gt; matchedCells = new List&lt;CellController&gt;();&#10;&#10;            if (!gridController.IsValidPosition(position)) return matchedCells;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall())&#10;                return matchedCells;&#10;&#10;            PieceColorEnum targetColor = cell.CellData.Piece.pieceColor;&#10;&#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul&#10;            HashSet&lt;Vector2Int&gt; connectedPositions = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedPositions);&#10;&#10;            // 3 veya daha fazla bağlı cell varsa listeye ekle&#10;            if (connectedPositions.Count &gt;= 3)&#10;            {&#10;                foreach (var pos in connectedPositions)&#10;                {&#10;                    matchedCells.Add(gridController.Cells[pos.y, pos.x]);&#10;                }&#10;            }&#10;&#10;            return matchedCells;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Rekursif olarak bağlı tüm aynı renkli cell'leri bulur&#10;        /// &lt;/summary&gt;&#10;        private void FindConnectedCells(Vector2Int position, PieceColorEnum targetColor, HashSet&lt;Vector2Int&gt; visited)&#10;        {&#10;            // Bu pozisyon zaten ziyaret edildiyse veya geçersizse dur&#10;            if (!gridController.IsValidPosition(position) || visited.Contains(position))&#10;                return;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;&#10;            // Boş, duvar veya farklı renk ise dur&#10;            if (cell.IsEmpty() || cell.IsWall() || !ColorsMatch(cell.CellData.Piece.pieceColor, targetColor))&#10;                return;&#10;&#10;            // Bu pozisyonu ziyaret edildi olarak işaretle&#10;            visited.Add(position);&#10;&#10;            // 4 yöne de (sağ, sol, yukarı, aşağı) rekursif olarak devam et&#10;            FindConnectedCells(position + Vector2Int.right, targetColor, visited); // Sağ&#10;            FindConnectedCells(position + Vector2Int.left, targetColor, visited); // Sol&#10;            FindConnectedCells(position + Vector2Int.up, targetColor, visited); // Yukarı&#10;            FindConnectedCells(position + Vector2Int.down, targetColor, visited); // Aşağı&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Eşleşen cell'lerde match animasyonu gecikmeyle tetikler&#10;        /// &lt;/summary&gt;&#10;        private IEnumerator TriggerMatchAnimations(List&lt;CellController&gt; matchedCells)&#10;        {&#10;            foreach (var cell in matchedCells)&#10;            {&#10;                cell.TriggerMatchAnimation();&#10;                yield return new WaitForSeconds(animationStartDelay);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Animasyonları tetikler ve ardından eşleşmeleri işler&#10;        /// &lt;/summary&gt;&#10;        private IEnumerator TriggerMatchAnimationsAndProcess(List&lt;CellController&gt; matchedCells)&#10;        {&#10;            // Tüm etkili cell'leri hesapla (normal matches + special piece effects)&#10;            HashSet&lt;CellController&gt; allCellsToDestroy = ProcessAllMatches(matchedCells);&#10;            Debug.Log($&quot;Total cells to destroy: {allCellsToDestroy.Count} (including special piece effects)&quot;);&#10;            &#10;            // HashSet'i List'e çevir (animasyon için)&#10;            List&lt;CellController&gt; finalMatchedCells = new List&lt;CellController&gt;(allCellsToDestroy);&#10;            &#10;            // Önce animasyonları tetikle&#10;            yield return StartCoroutine(TriggerMatchAnimations(finalMatchedCells));&#10;            &#10;            // Animasyon süresi kadar bekle&#10;            yield return new WaitForSeconds(animationDuration);&#10;            &#10;            // Cell'leri gerçekten yok et&#10;            foreach (var cell in allCellsToDestroy)&#10;            {&#10;                if (cell != null &amp;&amp; !cell.IsEmpty())&#10;                {&#10;                    cell.ClearPiece();&#10;                    Debug.Log($&quot;Destroyed piece at {cell.GridPosition}&quot;);&#10;                }&#10;            }&#10;            &#10;            Debug.Log($&quot;Cleared {allCellsToDestroy.Count} cells, now creating new pieces...&quot;);&#10;            &#10;            // Yeni piece'leri oluştur&#10;            yield return StartCoroutine(gridController.CreateNewPieces());&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Tüm eşleşmeleri ve özel piece etkilerini hesaplar&#10;        /// &lt;/summary&gt;&#10;        private HashSet&lt;CellController&gt; ProcessAllMatches(List&lt;CellController&gt; initialMatches)&#10;        {&#10;            HashSet&lt;CellController&gt; allCellsToDestroy = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Önce normal eşleşen cell'leri ekle&#10;            foreach (var cell in initialMatches)&#10;            {&#10;                allCellsToDestroy.Add(cell);&#10;            }&#10;            &#10;            // Özel piece'lerin etkilerini hesapla ve ekle&#10;            HashSet&lt;CellController&gt; specialEffects = CalculateSpecialPieceEffects(initialMatches);&#10;            foreach (var cell in specialEffects)&#10;            {&#10;                allCellsToDestroy.Add(cell);&#10;            }&#10;            &#10;            Debug.Log($&quot;Initial matches: {initialMatches.Count}, Special effects: {specialEffects.Count}, Total unique: {allCellsToDestroy.Count}&quot;);&#10;            return allCellsToDestroy;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Özel piece'lerin etkilerini hesaplar&#10;        /// &lt;/summary&gt;&#10;        private HashSet&lt;CellController&gt; CalculateSpecialPieceEffects(List&lt;CellController&gt; matchedCells)&#10;        {&#10;            HashSet&lt;CellController&gt; specialEffects = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Her matched cell'i kontrol et, özel piece ise etkilerini hesapla&#10;            foreach (var cell in matchedCells)&#10;            {&#10;                if (cell.CellData?.Piece == null) continue;&#10;                &#10;                var pieceType = cell.CellData.Piece.pieceTypeEnum;&#10;                Vector2Int pos = cell.GridPosition;&#10;&#10;                switch (pieceType)&#10;                {&#10;                    case PieceTypeEnum.Bomb:&#10;                        AddBombEffects(pos, specialEffects);&#10;                        break;&#10;&#10;                    case PieceTypeEnum.Row:&#10;                        AddRowEffects(pos, specialEffects);&#10;                        break;&#10;&#10;                    case PieceTypeEnum.Column:&#10;                        AddColumnEffects(pos, specialEffects);&#10;                        break;&#10;                }&#10;            }&#10;            &#10;            return specialEffects;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Bomba etkilerini hesaplar (3x3 alan)&#10;        /// &lt;/summary&gt;&#10;        private void AddBombEffects(Vector2Int bombPos, HashSet&lt;CellController&gt; effects)&#10;        {&#10;            for (int row = bombPos.y - 1; row &lt;= bombPos.y + 1; row++)&#10;            {&#10;                for (int col = bombPos.x - 1; col &lt;= bombPos.x + 1; col++)&#10;                {&#10;                    Vector2Int pos = new Vector2Int(col, row);&#10;                    if (gridController.IsValidPosition(pos) &amp;&amp; !gridController.Cells[pos.y, pos.x].IsWall())&#10;                    {&#10;                        effects.Add(gridController.Cells[pos.y, pos.x]);&#10;                        Debug.Log($&quot;Bomb at {bombPos} affects cell at {pos}&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Row piece etkilerini hesaplar (tüm satır)&#10;        /// &lt;/summary&gt;&#10;        private void AddRowEffects(Vector2Int rowPos, HashSet&lt;CellController&gt; effects)&#10;        {&#10;            int gridSize = gridController.Cells.GetLength(0);&#10;            &#10;            for (int col = 0; col &lt; gridSize; col++)&#10;            {&#10;                Vector2Int pos = new Vector2Int(col, rowPos.y);&#10;                if (gridController.IsValidPosition(pos) &amp;&amp; !gridController.Cells[pos.y, pos.x].IsWall())&#10;                {&#10;                    effects.Add(gridController.Cells[pos.y, pos.x]);&#10;                    Debug.Log($&quot;Row piece at {rowPos} affects cell at {pos}&quot;);&#10;                }&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Column piece etkilerini hesaplar (tüm sütun)&#10;        /// &lt;/summary&gt;&#10;        private void AddColumnEffects(Vector2Int colPos, HashSet&lt;CellController&gt; effects)&#10;        {&#10;            int gridSize = gridController.Cells.GetLength(0);&#10;            &#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                Vector2Int pos = new Vector2Int(colPos.x, row);&#10;                if (gridController.IsValidPosition(pos) &amp;&amp; !gridController.Cells[pos.y, pos.x].IsWall())&#10;                {&#10;                    effects.Add(gridController.Cells[pos.y, pos.x]);&#10;                    Debug.Log($&quot;Column piece at {colPos} affects cell at {pos}&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonlardaki cell'leri efekt ile yok eder&#10;        /// &lt;/summary&gt;&#10;        private IEnumerator DestroyCells(HashSet&lt;Vector2Int&gt; cellPositions)&#10;        {&#10;            // Cell'leri listesi haline getir ve sırala (görsel efekt için)&#10;            List&lt;Vector2Int&gt; sortedPositions = new List&lt;Vector2Int&gt;(cellPositions);&#10;&#10;            // Pozisyonları merkez noktasından dışarıya doğru sırala (daha güzel efekt için)&#10;            if (sortedPositions.Count &gt; 0)&#10;            {&#10;                Vector2 center = CalculateCenterPoint(sortedPositions);&#10;                sortedPositions.Sort((a, b) =&gt;&#10;                    Vector2.Distance(center, a).CompareTo(Vector2.Distance(center, b)));&#10;            }&#10;&#10;            // Her cell'i sırayla yok et&#10;            foreach (var pos in sortedPositions)&#10;            {&#10;                if (gridController.IsValidPosition(pos))&#10;                {&#10;                    CellController cell = gridController.Cells[pos.y, pos.x];&#10;                    if (!cell.IsEmpty() &amp;&amp; !cell.IsWall())&#10;                    {&#10;                        // Burada özel piece oluşturma kontrolü yap&#10;                        CheckAndCreateSpecialPiece(pos, sortedPositions.Count);&#10;&#10;                        // Cell'i yok et&#10;                        cell.ClearPiece();&#10;&#10;                        // Efekt gecikmesi&#10;                        yield return new WaitForSeconds(destructionEffectDelay);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Debug.Log($&quot;Destroyed {cellPositions.Count} cells with effects&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Pozisyonların merkez noktasını hesaplar&#10;        /// &lt;/summary&gt;&#10;        private Vector2 CalculateCenterPoint(List&lt;Vector2Int&gt; positions)&#10;        {&#10;            if (positions.Count == 0) return Vector2.zero;&#10;&#10;            float totalX = 0, totalY = 0;&#10;            foreach (var pos in positions)&#10;            {&#10;                totalX += pos.x;&#10;                totalY += pos.y;&#10;            }&#10;&#10;            return new Vector2(totalX / positions.Count, totalY / positions.Count);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Eşleşme sayısına göre özel piece oluşturup oluşturmayacağını kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private void CheckAndCreateSpecialPiece(Vector2Int position, int matchCount)&#10;        {&#10;            // Özel piece oluşturma şansını kontrol et&#10;            if (Random.value &gt; specialPieceChance) return;&#10;            &#10;&#10;            PieceTypeEnum? specialPieceType = null;&#10;&#10;            // Eşleşen cell sayısına göre özel piece türünü belirle&#10;            if (matchCount &gt;= minCellsForBomb)&#10;            {&#10;                specialPieceType = PieceTypeEnum.Bomb;&#10;                Debug.Log($&quot;Creating Bomb piece at {position} (matched {matchCount} cells)&quot;);&#10;            }&#10;            else if (matchCount &gt;= minCellsForRow)&#10;            {&#10;                // %50 şans ile Row veya Column&#10;                specialPieceType = Random.value &gt; 0.5f ? PieceTypeEnum.Row : PieceTypeEnum.Column;&#10;                Debug.Log($&quot;Creating {specialPieceType} piece at {position} (matched {matchCount} cells)&quot;);&#10;            }&#10;&#10;            // Özel piece'i oluştur&#10;            if (specialPieceType.HasValue)&#10;            {&#10;                CreateSpecialPieceAt(position, specialPieceType.Value);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda özel piece oluşturur&#10;        /// &lt;/summary&gt;&#10;        private void CreateSpecialPieceAt(Vector2Int position, PieceTypeEnum pieceType)&#10;        {&#10;            if (!gridController.IsValidPosition(position)) return;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsWall()) return;&#10;&#10;            // Rastgele renk seç (özel piece'ler herhangi bir renkte olabilir)&#10;            var availablePieces = gridController.GetComponent&lt;GridController&gt;().AvailablePieces;&#10;            if (availablePieces == null || availablePieces.Count == 0) return;&#10;&#10;            var basePiece = availablePieces[Random.Range(0, availablePieces.Count)];&#10;&#10;            // Özel piece oluştur&#10;            var specialPieceData = ScriptableObject.CreateInstance&lt;PieceSO&gt;();&#10;            specialPieceData.pieceTypeEnum = pieceType;&#10;            specialPieceData.Color = basePiece.Color;&#10;            specialPieceData.Sprite = basePiece.Sprite; // Burada özel sprite kullanılabilir&#10;            specialPieceData.pieceColor = basePiece.pieceColor;&#10;&#10;            var cellData = new CellData&#10;            {&#10;                Piece = specialPieceData,&#10;            };&#10;&#10;            cell.SetData(cellData);&#10;            Debug.Log($&quot;Created special {pieceType} piece at {position}&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki rengin eşleşip eşleşmediğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool ColorsMatch(PieceColorEnum color1, PieceColorEnum color2)&#10;        {&#10;            return color1 == color2;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using MiniGames.Match3.Data;&#10;&#10;namespace MiniGames.Match3.Core&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Match3 oyununda eşleşme işlemlerini yöneten sınıf&#10;    /// &lt;/summary&gt;&#10;    public class MatchController : MonoBehaviour&#10;    {&#10;        [Header(&quot;References&quot;)] [SerializeField]&#10;        private GridController gridController;&#10;&#10;        [Header(&quot;Match Settings&quot;)] [SerializeField]&#10;        private float matchProcessDelay = 1.0f;&#10;&#10;        [SerializeField] private float additionalDelay = 0.2f;&#10;        [SerializeField] private float destructionEffectDelay = 0.05f; // Her cell yok etme arasındaki efekt gecikmesi&#10;        [SerializeField] private float animationStartDelay = 0.1f; // Her animasyon başlatma arasındaki gecikme&#10;        [SerializeField] private float animationDuration = 0.5f; // Match animasyonunun süresi&#10;&#10;        [Header(&quot;Special Piece Generation&quot;)] [SerializeField]&#10;        private int minCellsForBomb = 7; // Bomba oluşturmak için minimum eşleşen cell sayısı&#10;&#10;        [SerializeField] private int minCellsForRow = 5; // Row piece oluşturmak için minimum cell sayısı&#10;        [SerializeField] private int minCellsForColumn = 5; // Column piece oluşturmak için minimum cell sayısı&#10;        [SerializeField] private float specialPieceChance = 0.1f; // Özel piece oluşturma şansı (0-1)&#10;&#10;        private void Awake()&#10;        {&#10;            if (gridController == null)&#10;                gridController = GetComponent&lt;GridController&gt;();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Swap yapılan cell'lerden etkilenen eşleşmeleri bulur ve işler&#10;        /// &lt;/summary&gt;&#10;        public void ProcessSwapMatches(CellController cell1, CellController cell2)&#10;        {&#10;            HashSet&lt;CellController&gt; allMatchedCells = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Her iki cell'den etkilenen eşleşmeleri bul ve HashSet'e ekle&#10;            AddMatchedCellsToSet(cell1.GridPosition, allMatchedCells);&#10;            AddMatchedCellsToSet(cell2.GridPosition, allMatchedCells);&#10;            &#10;            // Debug log ile eşleşen cell'lerin listesini yazdır&#10;            Debug.Log($&quot;=== SWAP MATCH RESULTS ===&quot;);&#10;            Debug.Log($&quot;Swapped cells: {cell1.GridPosition} &lt;-&gt; {cell2.GridPosition}&quot;);&#10;            Debug.Log($&quot;Total unique matches: {allMatchedCells.Count}&quot;);&#10;            &#10;            if (allMatchedCells.Count &gt; 0)&#10;            {&#10;                // Animasyonları gecikmeyle başlat ve ardından ProcessMatches'i çağır&#10;                StartCoroutine(TriggerMatchAnimationsAndProcess(allMatchedCells));&#10;            }&#10;            &#10;            Debug.Log($&quot;Match processing started for {allMatchedCells.Count} cells affected by swap&quot;);&#10;        }&#10;&#10;        public void ProcessMatchesAtCell(CellController startCell)&#10;        {&#10;            HashSet&lt;CellController&gt; allMatchedCells = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Cell'den etkilenen eşleşmeleri bul&#10;            AddMatchedCellsToSet(startCell.GridPosition, allMatchedCells);&#10;            &#10;            // Debug log ile eşleşen cell'lerin listesini yazdır&#10;            Debug.Log($&quot;=== MATCH RESULTS ===&quot;);&#10;            Debug.Log($&quot;Total unique matches: {allMatchedCells.Count}&quot;);&#10;            &#10;            if (allMatchedCells.Count &gt; 0)&#10;            {&#10;                // Animasyonları gecikmeyle başlat ve ardından ProcessMatches'i çağır&#10;                StartCoroutine(TriggerMatchAnimationsAndProcess(allMatchedCells));&#10;            }&#10;            &#10;            Debug.Log($&quot;Match processing started for {allMatchedCells.Count} cells affected by create&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyondaki eşleşen cell'leri HashSet'e ekler&#10;        /// &lt;/summary&gt;&#10;        private void AddMatchedCellsToSet(Vector2Int position, HashSet&lt;CellController&gt; targetSet)&#10;        {&#10;            if (!gridController.IsValidPosition(position)) return;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) return;&#10;&#10;            PieceColorEnum targetColor = cell.CellData.Piece.pieceColor;&#10;&#10;            // Birbirine bağlı tüm aynı renkli cell'lerin pozisyonlarını bul&#10;            HashSet&lt;Vector2Int&gt; connectedPositions = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedPositions);&#10;&#10;            // 3 veya daha fazla bağlı cell varsa HashSet'e ekle&#10;            if (connectedPositions.Count &gt;= 3)&#10;            {&#10;                foreach (var pos in connectedPositions)&#10;                {&#10;                    targetSet.Add(gridController.Cells[pos.y, pos.x]);&#10;                }&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda 3'lü match var mı kontrol eder&#10;        /// &lt;/summary&gt;&#10;        public bool CheckForMatches(Vector2Int position)&#10;        {&#10;            if (!gridController.IsValidPosition(position)) return false;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall()) return false;&#10;&#10;            PieceColorEnum targetColor = cell.CellData.Piece.pieceColor;&#10;&#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul (sarmal yapı)&#10;            HashSet&lt;Vector2Int&gt; connectedCells = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedCells);&#10;&#10;            // 3 veya daha fazla bağlı cell varsa match&#10;            return connectedCells.Count &gt;= 3;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyondaki tüm bağlı eşleşen cell'leri döndürür&#10;        /// &lt;/summary&gt;&#10;        private List&lt;CellController&gt; GetMatchedCellsAtPosition(Vector2Int position)&#10;        {&#10;            List&lt;CellController&gt; matchedCells = new List&lt;CellController&gt;();&#10;&#10;            if (!gridController.IsValidPosition(position)) return matchedCells;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsEmpty() || cell.IsWall())&#10;                return matchedCells;&#10;&#10;            PieceColorEnum targetColor = cell.CellData.Piece.pieceColor;&#10;&#10;            // Birbirine bağlı tüm aynı renkli cell'leri bul&#10;            HashSet&lt;Vector2Int&gt; connectedPositions = new HashSet&lt;Vector2Int&gt;();&#10;            FindConnectedCells(position, targetColor, connectedPositions);&#10;&#10;            // 3 veya daha fazla bağlı cell varsa listeye ekle&#10;            if (connectedPositions.Count &gt;= 3)&#10;            {&#10;                foreach (var pos in connectedPositions)&#10;                {&#10;                    matchedCells.Add(gridController.Cells[pos.y, pos.x]);&#10;                }&#10;            }&#10;&#10;            return matchedCells;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Rekursif olarak bağlı tüm aynı renkli cell'leri bulur&#10;        /// &lt;/summary&gt;&#10;        private void FindConnectedCells(Vector2Int position, PieceColorEnum targetColor, HashSet&lt;Vector2Int&gt; visited)&#10;        {&#10;            // Bu pozisyon zaten ziyaret edildiyse veya geçersizse dur&#10;            if (!gridController.IsValidPosition(position) || visited.Contains(position))&#10;                return;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;&#10;            // Boş, duvar veya farklı renk ise dur&#10;            if (cell.IsEmpty() || cell.IsWall() || !ColorsMatch(cell.CellData.Piece.pieceColor, targetColor))&#10;                return;&#10;&#10;            // Bu pozisyonu ziyaret edildi olarak işaretle&#10;            visited.Add(position);&#10;&#10;            // 4 yöne de (sağ, sol, yukarı, aşağı) rekursif olarak devam et&#10;            FindConnectedCells(position + Vector2Int.right, targetColor, visited); // Sağ&#10;            FindConnectedCells(position + Vector2Int.left, targetColor, visited); // Sol&#10;            FindConnectedCells(position + Vector2Int.up, targetColor, visited); // Yukarı&#10;            FindConnectedCells(position + Vector2Int.down, targetColor, visited); // Aşağı&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Eşleşen cell'lerde match animasyonu gecikmeyle tetikler&#10;        /// &lt;/summary&gt;&#10;        private IEnumerator TriggerMatchAnimations(HashSet&lt;CellController&gt; matchedCells)&#10;        {&#10;            foreach (var cell in matchedCells)&#10;            {&#10;                cell.TriggerMatchAnimation();&#10;                yield return new WaitForSeconds(animationStartDelay);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Animasyonları tetikler ve ardından eşleşmeleri işler&#10;        /// &lt;/summary&gt;&#10;        private IEnumerator TriggerMatchAnimationsAndProcess(HashSet&lt;CellController&gt; matchedCells)&#10;        {&#10;            // Tüm etkili cell'leri hesapla (normal matches + special piece effects)&#10;            HashSet&lt;CellController&gt; allCellsToDestroy = ProcessAllMatches(matchedCells);&#10;            Debug.Log($&quot;Total cells to destroy: {allCellsToDestroy.Count} (including special piece effects)&quot;);&#10;            &#10;            // Önce animasyonları tetikle&#10;            yield return StartCoroutine(TriggerMatchAnimations(allCellsToDestroy));&#10;            &#10;            // Animasyon süresi kadar bekle&#10;            yield return new WaitForSeconds(animationDuration);&#10;            &#10;            // Cell'leri gerçekten yok et&#10;            foreach (var cell in allCellsToDestroy)&#10;            {&#10;                if (cell != null &amp;&amp; !cell.IsEmpty())&#10;                {&#10;                    cell.ClearPiece();&#10;                    Debug.Log($&quot;Destroyed piece at {cell.GridPosition}&quot;);&#10;                }&#10;            }&#10;            &#10;            Debug.Log($&quot;Cleared {allCellsToDestroy.Count} cells, now creating new pieces...&quot;);&#10;            &#10;            // Yeni piece'leri oluştur&#10;            yield return StartCoroutine(gridController.CreateNewPieces());&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Tüm eşleşmeleri ve özel piece etkilerini hesaplar&#10;        /// &lt;/summary&gt;&#10;        private HashSet&lt;CellController&gt; ProcessAllMatches(HashSet&lt;CellController&gt; initialMatches)&#10;        {&#10;            HashSet&lt;CellController&gt; allCellsToDestroy = new HashSet&lt;CellController&gt;(initialMatches);&#10;            &#10;            // Özel piece'lerin etkilerini hesapla ve ekle&#10;            HashSet&lt;CellController&gt; specialEffects = CalculateSpecialPieceEffects(initialMatches);&#10;            allCellsToDestroy.UnionWith(specialEffects);&#10;            &#10;            Debug.Log($&quot;Initial matches: {initialMatches.Count}, Special effects: {specialEffects.Count}, Total unique: {allCellsToDestroy.Count}&quot;);&#10;            return allCellsToDestroy;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Özel piece'lerin etkilerini hesaplar&#10;        /// &lt;/summary&gt;&#10;        private HashSet&lt;CellController&gt; CalculateSpecialPieceEffects(HashSet&lt;CellController&gt; matchedCells)&#10;        {&#10;            HashSet&lt;CellController&gt; specialEffects = new HashSet&lt;CellController&gt;();&#10;            &#10;            // Her matched cell'i kontrol et, özel piece ise etkilerini hesapla&#10;            foreach (var cell in matchedCells)&#10;            {&#10;                if (cell.CellData?.Piece == null) continue;&#10;                &#10;                var pieceType = cell.CellData.Piece.pieceTypeEnum;&#10;                Vector2Int pos = cell.GridPosition;&#10;&#10;                switch (pieceType)&#10;                {&#10;                    case PieceTypeEnum.Bomb:&#10;                        AddBombEffects(pos, specialEffects);&#10;                        break;&#10;&#10;                    case PieceTypeEnum.Row:&#10;                        AddRowEffects(pos, specialEffects);&#10;                        break;&#10;&#10;                    case PieceTypeEnum.Column:&#10;                        AddColumnEffects(pos, specialEffects);&#10;                        break;&#10;                }&#10;            }&#10;            &#10;            return specialEffects;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Bomba etkilerini hesaplar (3x3 alan)&#10;        /// &lt;/summary&gt;&#10;        private void AddBombEffects(Vector2Int bombPos, HashSet&lt;CellController&gt; effects)&#10;        {&#10;            for (int row = bombPos.y - 1; row &lt;= bombPos.y + 1; row++)&#10;            {&#10;                for (int col = bombPos.x - 1; col &lt;= bombPos.x + 1; col++)&#10;                {&#10;                    Vector2Int pos = new Vector2Int(col, row);&#10;                    if (gridController.IsValidPosition(pos) &amp;&amp; !gridController.Cells[pos.y, pos.x].IsWall())&#10;                    {&#10;                        effects.Add(gridController.Cells[pos.y, pos.x]);&#10;                        Debug.Log($&quot;Bomb at {bombPos} affects cell at {pos}&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Row piece etkilerini hesaplar (tüm satır)&#10;        /// &lt;/summary&gt;&#10;        private void AddRowEffects(Vector2Int rowPos, HashSet&lt;CellController&gt; effects)&#10;        {&#10;            int gridSize = gridController.Cells.GetLength(0);&#10;            &#10;            for (int col = 0; col &lt; gridSize; col++)&#10;            {&#10;                Vector2Int pos = new Vector2Int(col, rowPos.y);&#10;                if (gridController.IsValidPosition(pos) &amp;&amp; !gridController.Cells[pos.y, pos.x].IsWall())&#10;                {&#10;                    effects.Add(gridController.Cells[pos.y, pos.x]);&#10;                    Debug.Log($&quot;Row piece at {rowPos} affects cell at {pos}&quot;);&#10;                }&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Column piece etkilerini hesaplar (tüm sütun)&#10;        /// &lt;/summary&gt;&#10;        private void AddColumnEffects(Vector2Int colPos, HashSet&lt;CellController&gt; effects)&#10;        {&#10;            int gridSize = gridController.Cells.GetLength(0);&#10;            &#10;            for (int row = 0; row &lt; gridSize; row++)&#10;            {&#10;                Vector2Int pos = new Vector2Int(colPos.x, row);&#10;                if (gridController.IsValidPosition(pos) &amp;&amp; !gridController.Cells[pos.y, pos.x].IsWall())&#10;                {&#10;                    effects.Add(gridController.Cells[pos.y, pos.x]);&#10;                    Debug.Log($&quot;Column piece at {colPos} affects cell at {pos}&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonlardaki cell'leri efekt ile yok eder&#10;        /// &lt;/summary&gt;&#10;        private IEnumerator DestroyCells(HashSet&lt;Vector2Int&gt; cellPositions)&#10;        {&#10;            // Cell'leri listesi haline getir ve sırala (görsel efekt için)&#10;            List&lt;Vector2Int&gt; sortedPositions = new List&lt;Vector2Int&gt;(cellPositions);&#10;&#10;            // Pozisyonları merkez noktasından dışarıya doğru sırala (daha güzel efekt için)&#10;            if (sortedPositions.Count &gt; 0)&#10;            {&#10;                Vector2 center = CalculateCenterPoint(sortedPositions);&#10;                sortedPositions.Sort((a, b) =&gt;&#10;                    Vector2.Distance(center, a).CompareTo(Vector2.Distance(center, b)));&#10;            }&#10;&#10;            // Her cell'i sırayla yok et&#10;            foreach (var pos in sortedPositions)&#10;            {&#10;                if (gridController.IsValidPosition(pos))&#10;                {&#10;                    CellController cell = gridController.Cells[pos.y, pos.x];&#10;                    if (!cell.IsEmpty() &amp;&amp; !cell.IsWall())&#10;                    {&#10;                        // Burada özel piece oluşturma kontrolü yap&#10;                        CheckAndCreateSpecialPiece(pos, sortedPositions.Count);&#10;&#10;                        // Cell'i yok et&#10;                        cell.ClearPiece();&#10;&#10;                        // Efekt gecikmesi&#10;                        yield return new WaitForSeconds(destructionEffectDelay);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Debug.Log($&quot;Destroyed {cellPositions.Count} cells with effects&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Pozisyonların merkez noktasını hesaplar&#10;        /// &lt;/summary&gt;&#10;        private Vector2 CalculateCenterPoint(List&lt;Vector2Int&gt; positions)&#10;        {&#10;            if (positions.Count == 0) return Vector2.zero;&#10;&#10;            float totalX = 0, totalY = 0;&#10;            foreach (var pos in positions)&#10;            {&#10;                totalX += pos.x;&#10;                totalY += pos.y;&#10;            }&#10;&#10;            return new Vector2(totalX / positions.Count, totalY / positions.Count);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Eşleşme sayısına göre özel piece oluşturup oluşturmayacağını kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private void CheckAndCreateSpecialPiece(Vector2Int position, int matchCount)&#10;        {&#10;            // Özel piece oluşturma şansını kontrol et&#10;            if (Random.value &gt; specialPieceChance) return;&#10;            &#10;&#10;            PieceTypeEnum? specialPieceType = null;&#10;&#10;            // Eşleşen cell sayısına göre özel piece türünü belirle&#10;            if (matchCount &gt;= minCellsForBomb)&#10;            {&#10;                specialPieceType = PieceTypeEnum.Bomb;&#10;                Debug.Log($&quot;Creating Bomb piece at {position} (matched {matchCount} cells)&quot;);&#10;            }&#10;            else if (matchCount &gt;= minCellsForRow)&#10;            {&#10;                // %50 şans ile Row veya Column&#10;                specialPieceType = Random.value &gt; 0.5f ? PieceTypeEnum.Row : PieceTypeEnum.Column;&#10;                Debug.Log($&quot;Creating {specialPieceType} piece at {position} (matched {matchCount} cells)&quot;);&#10;            }&#10;&#10;            // Özel piece'i oluştur&#10;            if (specialPieceType.HasValue)&#10;            {&#10;                CreateSpecialPieceAt(position, specialPieceType.Value);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Belirtilen pozisyonda özel piece oluşturur&#10;        /// &lt;/summary&gt;&#10;        private void CreateSpecialPieceAt(Vector2Int position, PieceTypeEnum pieceType)&#10;        {&#10;            if (!gridController.IsValidPosition(position)) return;&#10;&#10;            CellController cell = gridController.Cells[position.y, position.x];&#10;            if (cell.IsWall()) return;&#10;&#10;            // Rastgele renk seç (özel piece'ler herhangi bir renkte olabilir)&#10;            var availablePieces = gridController.GetComponent&lt;GridController&gt;().AvailablePieces;&#10;            if (availablePieces == null || availablePieces.Count == 0) return;&#10;&#10;            var basePiece = availablePieces[Random.Range(0, availablePieces.Count)];&#10;&#10;            // Özel piece oluştur&#10;            var specialPieceData = ScriptableObject.CreateInstance&lt;PieceSO&gt;();&#10;            specialPieceData.pieceTypeEnum = pieceType;&#10;            specialPieceData.Color = basePiece.Color;&#10;            specialPieceData.Sprite = basePiece.Sprite; // Burada özel sprite kullanılabilir&#10;            specialPieceData.pieceColor = basePiece.pieceColor;&#10;&#10;            var cellData = new CellData&#10;            {&#10;                Piece = specialPieceData,&#10;            };&#10;&#10;            cell.SetData(cellData);&#10;            Debug.Log($&quot;Created special {pieceType} piece at {position}&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// İki rengin eşleşip eşleşmediğini kontrol eder&#10;        /// &lt;/summary&gt;&#10;        private bool ColorsMatch(PieceColorEnum color1, PieceColorEnum color2)&#10;        {&#10;            return color1 == color2;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Match3Game.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System;&#10;using MiniGameFramework.Core;&#10;using MiniGameFramework.Events;&#10;&#10;namespace MiniGameFramework.Match3&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#10;    /// Extends MiniGameBase for framework integration&#10;    /// &lt;/summary&gt;&#10;    public class Match3Game : MiniGameBase&#10;    {&#10;        [Header(&quot;Game Configuration&quot;)]&#10;        [SerializeField] private int targetScore = 1000;&#10;        [SerializeField] private int movesLimit = 30;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#10;        &#10;        [Header(&quot;System References&quot;)]&#10;        [SerializeField] private GridManager gridManager;&#10;        [SerializeField] private InputHandler inputHandler;&#10;        [SerializeField] private SwapHandler swapHandler;&#10;        [SerializeField] private MatchFinder matchFinder;&#10;        [SerializeField] private RefillSystem refillSystem;&#10;        &#10;        // Game state&#10;        private int movesRemaining;&#10;        private int cascadeLevel;&#10;        private bool isProcessingMatches;&#10;        private GameState gameState;&#10;        &#10;        // Additional events specific to Match-3&#10;        public event Action&lt;int&gt; OnMovesChanged;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#10;        public event Action OnCascadeStarted;&#10;        public event Action OnCascadeEnded;&#10;        &#10;        // IMiniGame Implementation&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#10;        public bool IsInitialized { get; private set; }&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#10;&#10;        // Events&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#10;&#10;        // Properties&#10;        public int CurrentScore =&gt; currentScore;&#10;        public int MovesRemaining =&gt; movesRemaining;&#10;        public int TargetScore =&gt; targetScore;&#10;        public GameState State =&gt; gameState;&#10;        &#10;        private void Awake()&#10;        {&#10;            ValidateComponents();&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        private void ValidateComponents()&#10;        {&#10;            if (gridManager == null) gridManager = GetComponent&lt;GridManager&gt;();&#10;            if (inputHandler == null) inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            if (swapHandler == null) swapHandler = GetComponent&lt;SwapHandler&gt;();&#10;            if (matchFinder == null) matchFinder = GetComponent&lt;MatchFinder&gt;();&#10;            if (refillSystem == null) refillSystem = GetComponent&lt;RefillSystem&gt;();&#10;        }&#10;        &#10;        #region MiniGameBase Overrides&#10;        &#10;        protected override void OnInitialize()&#10;        {&#10;            // Initialize all systems&#10;            matchFinder.Initialize(gridManager);&#10;            swapHandler.Initialize(gridManager, matchFinder);&#10;            inputHandler.Initialize(gridManager, swapHandler);&#10;            refillSystem.Initialize(gridManager);&#10;            &#10;            // Subscribe to events&#10;            SubscribeToEvents();&#10;            &#10;            // Setup initial grid&#10;            refillSystem.InitialFillGrid();&#10;            &#10;            // Ensure no initial matches&#10;            StartCoroutine(ClearInitialMatches());&#10;        }&#10;        &#10;        protected override void OnGameStart()&#10;        {&#10;            // Reset game state&#10;            movesRemaining = movesLimit;&#10;            cascadeLevel = 0;&#10;            isProcessingMatches = false;&#10;            &#10;            // Enable input&#10;            inputHandler.SetInputEnabled(true);&#10;            &#10;            gameState = GameState.Playing;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            &#10;            // Publish game started event&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Ready, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGamePause()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Paused;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Paused));&#10;        }&#10;        &#10;        protected override void OnGameResume()&#10;        {&#10;            inputHandler.SetInputEnabled(true);&#10;            gameState = GameState.Playing;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Paused, GameState.Playing));&#10;        }&#10;        &#10;        protected override void OnGameEnd()&#10;        {&#10;            inputHandler.SetInputEnabled(false);&#10;            gameState = GameState.Ended;&#10;             Events.Events.Publish(new GameStateChangedEvent(GameState.Playing, GameState.Ended));&#10;        }&#10;        &#10;        protected override void OnCleanup()&#10;        {&#10;            UnsubscribeFromEvents();&#10;            &#10;            if (gridManager != null)&#10;                gridManager.ClearGrid();&#10;&#10;            gameState = GameState.NotInitialized;&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Event Handling&#10;        &#10;        private void SubscribeToEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted += OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted += OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            if (swapHandler != null)&#10;            {&#10;                swapHandler.OnSwapCompleted -= OnSwapCompleted;&#10;            }&#10;            &#10;            if (refillSystem != null)&#10;            {&#10;                refillSystem.OnRefillCompleted -= OnRefillCompleted;&#10;            }&#10;        }&#10;        &#10;        private void OnSwapCompleted(Vector2Int pos1, Vector2Int pos2, bool wasSuccessful)&#10;        {&#10;            if (!IsGameActive()) return;&#10;            &#10;            // Publish swap event&#10;            Events.Events.Publish(new PieceSwappedEvent(pos1, pos2, wasSuccessful));&#10;            &#10;            if (wasSuccessful)&#10;            {&#10;                // Consume a move&#10;                movesRemaining--;&#10;                OnMovesChanged?.Invoke(movesRemaining);&#10;                Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;                &#10;                // Start cascade processing&#10;                StartCoroutine(ProcessMatches());&#10;                &#10;                // Check for game over conditions&#10;                if (movesRemaining &lt;= 0)&#10;                {&#10;                    StartCoroutine(CheckGameOverAfterCascade());&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void OnRefillCompleted()&#10;        {&#10;            if (!IsPlaying) return;&#10;            &#10;            // Check for new matches after refill&#10;            StartCoroutine(ProcessMatches());&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Match Processing and Cascades&#10;        &#10;        private IEnumerator ProcessMatches()&#10;        {&#10;            if (isProcessingMatches) yield break;&#10;            &#10;            isProcessingMatches = true;&#10;            cascadeLevel = 0;&#10;            int totalCascadeScore = 0;&#10;            &#10;            OnCascadeStarted?.Invoke();&#10;            Events.Events.Publish(new CascadeStartedEvent(cascadeLevel));&#10;            &#10;            bool foundMatches;&#10;            do&#10;            {&#10;                cascadeLevel++;&#10;                &#10;                // Find all matches&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                foundMatches = matches.Count &gt; 0;&#10;                &#10;                if (foundMatches)&#10;                {&#10;                    // Process matches and get the score for this cascade&#10;                    int cascadeScore = ProcessMatchedPieces(matches);&#10;                    totalCascadeScore += cascadeScore;&#10;&#10;                    // Wait for destruction animations to complete&#10;                    yield return new WaitForSeconds(0.5f);&#10;                    &#10;                    // Apply gravity and refill&#10;                    yield return StartCoroutine(refillSystem.RefillGrid());&#10;                    &#10;                    // Wait before checking for new matches&#10;                    yield return new WaitForSeconds(cascadeDelay);&#10;                }&#10;                &#10;            } while (foundMatches);&#10;            &#10;            isProcessingMatches = false;&#10;            OnCascadeEnded?.Invoke();&#10;            Events.Events.Publish(new CascadeEndedEvent(cascadeLevel - 1, totalCascadeScore));&#10;        }&#10;        &#10;        private int ProcessMatchedPieces(List&lt;List&lt;Vector2Int&gt;&gt; matches)&#10;        {&#10;            List&lt;Piece&gt; matchedPieces = new List&lt;Piece&gt;();&#10;            int matchScore = 0;&#10;            &#10;            foreach (var match in matches)&#10;            {&#10;                int matchValue = 0;&#10;                List&lt;Vector2Int&gt; matchPositions = new List&lt;Vector2Int&gt;();&#10;                &#10;                foreach (var position in match)&#10;                {&#10;                    Piece piece = gridManager.GetPiece(position);&#10;                    if (piece != null &amp;&amp; !matchedPieces.Contains(piece))&#10;                    {&#10;                        matchedPieces.Add(piece);&#10;                        matchPositions.Add(position);&#10;                        &#10;                        int pieceScore = piece.GetScore();&#10;                        // Apply cascade multiplier&#10;                        pieceScore *= cascadeLevel;&#10;                        matchValue += pieceScore;&#10;                        &#10;                        // Handle special pieces&#10;                        if (piece.IsSpecial)&#10;                        {&#10;                            piece.ActivateSpecialEffect(position);&#10;                            int specialScore = piece.GetScore(true) * cascadeLevel;&#10;                            matchValue += specialScore;&#10;                            &#10;                            // Publish special piece event&#10;                            Events.Events.Publish(new SpecialPieceActivatedEvent(position, piece.SpecialType, new List&lt;Vector2Int&gt; { position }));&#10;                        }&#10;                        &#10;                        // Trigger match notification&#10;                        piece.OnMatched();&#10;                        &#10;                        // Remove from grid&#10;                        gridManager.RemovePiece(position);&#10;                        &#10;                        // Destroy piece&#10;                        piece.Destroy();&#10;                    }&#10;                }&#10;                &#10;                // Publish match found event&#10;                if (matchPositions.Count &gt; 0)&#10;                {&#10;                    Events.Events.Publish(new MatchFoundEvent(matchPositions, matchValue));&#10;                }&#10;                &#10;                matchScore += matchValue;&#10;            }&#10;            &#10;            // Add score using base class method&#10;            AddScore(matchScore);&#10;            &#10;            OnPiecesMatched?.Invoke(matchedPieces);&#10;            &#10;            return matchScore;&#10;        }&#10;        &#10;        private IEnumerator ClearInitialMatches()&#10;        {&#10;            // Keep clearing matches until no more exist&#10;            while (true)&#10;            {&#10;                List&lt;List&lt;Vector2Int&gt;&gt; matches = matchFinder.FindAllMatches();&#10;                if (matches.Count == 0) break;&#10;                &#10;                // Destroy matched pieces without scoring&#10;                foreach (var match in matches)&#10;                {&#10;                    foreach (var position in match)&#10;                    {&#10;                        Piece piece = gridManager.GetPiece(position);&#10;                        if (piece != null)&#10;                        {&#10;                            gridManager.RemovePiece(position);&#10;                            Destroy(piece.gameObject);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Refill and check again&#10;                yield return StartCoroutine(refillSystem.RefillGrid());&#10;                yield return new WaitForSeconds(0.1f);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Game Over Logic&#10;        &#10;        private IEnumerator CheckGameOverAfterCascade()&#10;        {&#10;            // Wait for current cascade to finish&#10;            while (isProcessingMatches || refillSystem.IsRefilling)&#10;            {&#10;                yield return null;&#10;            }&#10;            &#10;            CheckGameOverConditions();&#10;        }&#10;        &#10;        private void CheckGameOverConditions()&#10;        {&#10;            // Check win condition&#10;            if (currentScore &gt;= targetScore)&#10;            {&#10;                EndGame();&#10;                return;&#10;            }&#10;            &#10;            // Check loss conditions&#10;            if (movesRemaining &lt;= 0)&#10;            {&#10;                // Check if there are still possible moves&#10;                if (!matchFinder.HasPossibleMoves())&#10;                {&#10;                    EndGame();&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Public Interface&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus moves (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public void AddMoves(int moves)&#10;        {&#10;            movesRemaining += moves;&#10;            OnMovesChanged?.Invoke(movesRemaining);&#10;            Events.Events.Publish(new MovesUpdatedEvent(movesRemaining, movesLimit - movesRemaining));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Add bonus score (for power-ups or special events)&#10;        /// &lt;/summary&gt;&#10;        public new void AddScore(int score)&#10;        {&#10;            base.AddScore(score);&#10;            Events.Events.Publish(new ScoreUpdatedEvent(currentScore, score));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if the game can continue&#10;        /// &lt;/summary&gt;&#10;        public bool CanContinue()&#10;        {&#10;            return movesRemaining &gt; 0 &amp;&amp; matchFinder.HasPossibleMoves();&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Represents the current state of the Match-3 game&#10;    /// &lt;/summary&gt;&#10;    public enum GameState&#10;    {&#10;        NotInitialized,&#10;        Ready,&#10;        Playing,&#10;        Paused,&#10;        Ended&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using System.Collections;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System;&#13;&#10;using MiniGameFramework.Core;&#13;&#10;using MiniGameFramework.Events;&#13;&#10;&#13;&#10;namespace MiniGameFramework.Match3&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Main controller for the Match-3 game that orchestrates all systems&#13;&#10;    /// Extends MiniGameBase for framework integration&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public class Match3Game : MiniGameBase&#13;&#10;    {&#13;&#10;        [Header(&quot;Game Configuration&quot;)]&#13;&#10;        [SerializeField] private int targetScore = 1000;&#13;&#10;        [SerializeField] private int movesLimit = 30;&#13;&#10;        [SerializeField] private float cascadeDelay = 0.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;System References&quot;)]&#13;&#10;        [SerializeField] private GridManager gridManager;&#13;&#10;        [SerializeField] private InputHandler inputHandler;&#13;&#10;        [SerializeField] private SwapHandler swapHandler;&#13;&#10;        [SerializeField] private MatchFinder matchFinder;&#13;&#10;        [SerializeField] private RefillSystem refillSystem;&#13;&#10;        &#13;&#10;        // Game state&#13;&#10;        private int _currentScore;&#13;&#10;        private int movesRemaining;&#13;&#10;        private int cascadeLevel;&#13;&#10;        private bool isProcessingMatches;&#13;&#10;        private GameState gameState;&#13;&#10;        &#13;&#10;        // Additional events specific to Match-3&#13;&#10;        public event Action&lt;int&gt; OnMovesChanged;&#13;&#10;        public event Action&lt;List&lt;Piece&gt;&gt; OnPiecesMatched;&#13;&#10;        public event Action OnCascadeStarted;&#13;&#10;        public event Action OnCascadeEnded;&#13;&#10;        &#13;&#10;        // IMiniGame Implementation&#13;&#10;        public string GameName =&gt; &quot;Match-3 Puzzle&quot;;&#13;&#10;        public bool IsInitialized { get; private set; }&#13;&#10;        public bool IsPlaying =&gt; gameState == GameState.Playing;&#13;&#10;&#13;&#10;        // Events&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameStarted;&#13;&#10;        public event Action&lt;IMiniGame&gt; OnGameEnded;&#13;&#10;        public event Action&lt;IMiniGame, int&gt; OnScoreChanged;&#13;&#10;&#13;&#10;        // Properties&#13;&#10;        public int CurrentScore =&gt; _currentScore;&#13;&#10;        public int MovesRemaining =&gt; movesRemaining;&#13;&#10;        public int TargetScore =&gt; targetScore;&#13;&#10;        public GameState State =&gt; gameState;&#13;&#10;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public enum GameState&#13;&#10;    {&#13;&#10;        Initializing,&#13;&#10;        Ready,&#13;&#10;        Playing,&#13;&#10;        Paused,&#13;&#10;        GameOver&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/MiniGames/Match3/Piece.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/EventTester.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Test/TestEventClass.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>